// * === Алгоритм реконциляции (согласования\сверки) в Реакт. Работа со списками. VirtualDOM (129) === * \\

// ? Мы уже знаем из более ранних уроков, что для браузера работа с обычной DOM-структурой довольно ресурсоёмкая задача, особенно, если в неё огромное количество элементов, которые динамически меняются. А современные веб-приложения это как раз динамичная структура, в нём постоянно будет что-то меняться, данные уходить и приходить, изменяться и т.п. При всех этих манипуляциях идёт постоянное перестроение DOM-структуры. Обычная DOM-структура была нацелена на статику. Поэтому одно из решений разгрузить устройство пользователя — VirtualDOM.
// Представим, что в нашем приложении Employees List не 3 сотрудника, а 3000. И вот в середине списка появился один или одного удалили. Или у кого-то поменялись пропсы. Что в этом случае должен сделать Реакт? Он должен перерисовать все 3000 компонентов. Или найти изменившегося и что-то сделать с ним. И как раз здесь сильно поможет алгоритм реконциляции.
// * Рассмотрим на примере как он работает. Представим unordered list, в котором лежат все наши элементы. И вот если мы поменяем тег родительского элемента с ul на div, то реакт подумает, что раз поменялась корневая сущность, то внутри всё также поменялось и произойдёт полное уничтожение DOM-дерева. Всё содержимое будет уничтожено и в приложении создано заново. Возможно это покажется не оптимизированным, но в этом есть свои плюсы. Если меняется главный родитель, но для безопасности самого приложения лучше перестроить всё внутри него.
// ? Такая же ситуация будет происходить, когда мы станем переключать страницы в одностраничном приложении. Но об этом позже.
// * Если же в корневом элементе поменяется не тип элемента, а только его атрибуты, например пропсы или атрибуты класса, дата-атрибуты и т.д., то реакт будет обновлять только изменившийся элемент. Т.е. если мы динамически добавим какой-то CSS-класс, тогда будет удалён только родительский тег ul, не цепляя его внутренних элементов и заменён на другой тег ul с изменёнными атрибутами.
// * В предыдущем уроке мы говорили, что элементы внутри компонента у нас неизменяемы. Мы можем их поменять на странице только если их полностью перерендерим. 
// * А дальше алгоритм пойдёт рекурсивно по всем дочерним элементам, которые находятся внутри этого ul родительского элемента. Там будет сверено есть ли отличия. И вот как работает это внутри: React сохраняет точную копию дерева всех элементов и компонентов, при этом сохраняет и новое дерево, которое должно быть построено. И всё это происходит в VirtualDOM-дереве. Дальше идёт одновременное сравнение каждого элемента друг с другом. Если реакт находит отличие, то изменённые элементы будут создавать мутацию. Т.е. создавать перерисовку этого элемента в реальном DOM-дереве. Другими словами реакт заново перерендерит в реальном DOM-дереве только те элементы, которые реально изменились. Остальные останутся нетронутыми.
// ? Но тут есть одна проблема и касается она одинаковых элементов.
// Обратимся к нашему примеру в Employees List App с сотрудниками. И вот, если у нас есть список с одинаковыми сотрудниками, то как алгоритм поймёт, что сотрудник изменился? На базовом уровне сравнение идёт просто по порядку. И если мы добавим нового сотрудника в конце списка, то идущий перед ним список всех сотрудников никак не изменится, ведь их очерёдность не изменилась. Но если мы поставим его перед всеми на первое место, то ситуация изменится. В последнем случае реакт посчитает, что весь наш список поменялся, ведь порядок элементов списка тоже поменялся. И тогда он начнёт рендерить весь список заново, а это удар по производительности.
// * И поэтому в таких случаях, когда формируются одинаковые элементы при помощи методов map(), filter() и т.д. нам нужно что-то, что будет говорить алгоритму реакта, что это всё тот же элемент или компонент. Как бы говоря алгоритму «Не меняй меня, мой идентификатор остался тем же и я сам не менялся, оставь меня как есть и иди дальше!». Таким идентификатором выступает атрибут key, именно по этому атрибуту\пропсу реакт определит поменялся ли элемент или нет, вне зависимости от его порядкового номера, относительно прошлого. Добавим это и в наш проект projects/react-project-2-employees. ->
// ? Пока укажем в нашей фиктивной "локальной БД" простейшие идентификаторы для примера, но на реальных проекта, пришедшие с сервера файлы обычно имеют идентификаторы в виде довольно объёмного набора каких-то символов, который приходит уникальным ключом.
// ? Стоит также отметить, что эти ключи должны быть уникальны только среди их соседей, а не глобально. Т.е. если те же самый ключи будут где-то в других списках, в другой части того же приложения, то в этом нет ничего страшного. Т.к. они действуют для конкретного списка элементов, чтобы их отличать друг от друга, как описано выше.
// Во многих других элементах UI всё куда проще, если там элементы и компоненты сильно отличаются друг от друга, потому и не нуждаются в этом атрибуте.

// todo Для наглядности взглянем на [projects/react-project-2-employees/src/components/employees-list.jsx].

// |===:===:===:===>
/** links:
 * (EN Новая документация): https://react.dev/learn/preserving-and-resetting-state
 * (Базовая документация): https://ru.reactjs.org/docs/reconciliation.html
 * (Перевод новой документации): https://reactdev.ru/learn/preserving-and-resetting-state/
 * */
