'use strict';

// * === Что такое библиотека React JS? SPA-приложения. (119-120) === * \\

// ? Зачем же разработчики придумали надстройки, а не используют нативный JS, ведь в нём тоже можно делать всё что угодно? Всё дело в оптимизации, как рабочего процесса, так и самой разработки продуктов. Прежде, работая в предыдущих модулях с нативным JS мы не слишком уделяли внимания оптимизации. Насколько быстро работает или сколько памяти потребляет и прочие крайне важные в реальных проектах вопросы. У нас было не так много элементов взаимодействия. Для разработки более сложных веб-приложений требуются более продвинутые инструменты.

// ? React JS — это библиотека на основе ЯП JavaScript, которая помогает работать быстрее, избегать багов и ошибок, создавать более оптимизированный продукт. Сама концепция библиотеки заключается в том, что она помогает создавать SPA (Single Page Application) или одностраничные веб-приложения. Они ведут себя крайне отзывчиво, работают быстро и выглядят как самые настоящие программы, которые установлены на компьютере или в телефоне. Они взаимодействуют с пользователем и реагируют на каждое его действие изменением внешнего вида (UI - User Interface), в этом и заключается главная задача веб-приложений — изменять страницу без перезагрузок. При этом оно будет ещё и контролировать расход памяти браузером, чтобы он не зависал.

// * React JS использует декларативный подход. Декларативный подход говорит какой результат нам нужен. В то время как императивный подход говорит как именно дойти к результату (конкретные шаги).
// Чтобы проще представить разницу, императивный подход, а это когда, например вы пришли с друзьями в ресторан и говорите, мы сейчас пойдём в глубь ресторана и сядем за тот столик у окна. Декларативный подход это когда вы приходите в ресторан и говорите официантке: «Столик на 5-ых пожалуйста!» Т.е. вам не важны шаги, как вы туда доберётесь (увидите столик, пройдёте к нему и т.д.), а просто говорите какой результат вам требуется.
// * Вернёмся обратно к примеру с UI: Итак, у нас есть модальное окно, если возьмём императивный подход, т.е. как мы его реализуем, то у нас есть конечная цель показать это окно. Императивным подходом мы можем его описать: «Вот, у нас есть кнопка с определённым классом и если пользователь кликнет на эту кнопку, то у нас откроется модальное окно.» Т.е. есть конкретные шаги для того, чтобы открыть модальное окно.
// * Если мы применим декларативный подход, то результат будет такой же — мы откроем модальное окно. Но здесь мы опишем только конечный результат: «Нам нужно, чтобы модальное окно было открыто.» (а каким образом это произойдёт не так важно).

// * React JS основан на компонентах. Каждое веб-приложение построено из множества повторяющихся, иногда сотни раз маленьких компонентов. Они компактны и независимы, также как и функции. Мы сможем их повторно использовать при создании приложений и удобно тестировать. Т.к. они не зависят друг от друга, то они могут быть легко изменены или удалены и отлично укладываются в BEM-культуру. Также они обеспечивают сохранить чистоту глобального пространства и избежать проблем с одинаковыми именами. Ведь все данные компонента существуют в собственно области видимости. Также можно будет легко переносить какие-то наработки из проекта в проект и использовать повторно немного изменяя под новую задачу.

// * Позже, если потребуется будет намного проще изучить React Native JS, библиотеку на базе React JS для создания мобильный приложений.
// * Или даже библиотека для создания виртуальной реальности в браузере React 360. И некоторые другие.

// * >=======< * \\

// ? В своей работе React JS использует препроцессор JSX (эдакая помесь HTML и JavaScript). React-компоненты реализуют метод render(), который принимает входные данные и возвращает что-то для вывода. В этом примере используется синтаксис JSX. Входные данные, передаваемые в компонент, доступны в render() через this.props. Однако мы можем также использовать и JavaScript. Никаких проблем с этим нет, т.к. он базируется на обычном нативном JavaScript. Хотя JSX позволяет одновременно писать и HTML и логику к нему экономя время.
class HelloMessage extends React.Component {
  render() {
    return (
      <div>
        Hello, {this.props.name}
      </div>
    );
  }
}

React.DOM.render {
  <HelloMessage name="Саша" />
  document.getElementById('hello-example')
};

// ? Внутри React JS есть алгоритм, который позволяет отслеживать какие части приложения изменились и обновить только их, а не всё приложение целиком. Он называется "reconciliation algorithm" (алгоритм сравнения\согласования\реконсиляции).
// Представим, что к нам пришли какие-то данные от сервера и на основании этих данных мы построим какой-то список элементов. Затем к нам приходят ещё раз эти данные, но уже изменённые. И когда мы хотим обновить UI на базе этих данных, то здесь поможет этот алгоритм, т.к. изменит только изменившиеся части этих данных, а остальное останется на странице не тронутым.

// ? Технология VirtualDOM — стандартное DOM-дерево это достаточно громоздкая структура, которая изначально не была предназначена для работы с динамически обновляемым контентом. VirtualDOM — по сути более лёгкая копия DOM-дерева в которой мы сперва работаем, а потом переносим изменения в обычное DOM-дерево. Благодаря этой технологии, компоненты создаваемые в React JS будут выглядеть намного проще с минимум необходимых свойств и тогда, на действительно больших проектах это сэкономит большое количество памяти пользовательскому устройству для загрузки и пользования.

// |===:===:===:===>
/** links:
 * (EN Новая документация): https://react.dev/learn
 * (RU Перевод новой документации): https://reactdev.ru/learn/
 * (RU Официальная документация): https://ru.reactjs.org/
 * */
