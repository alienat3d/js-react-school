'use strict';

// * === Работа с глобальным объектом Date === * \\
// ? Работа с Date является обязательным навыком, ведь у нас множество ситуаций, где можно его применять.
// Например его можно использовать для измерения времени работы какой-то функции. Если мы хотим засечь как быстро она работает и сравнить с другой функцией. Можно использовать для вывода текущей даты, например это может быть таймер или часы на странице. Также для хранения времени создания или изменения какого-то документа.
const now = new Date(); // т.к. здесь мы круглые скобки не заполнили, то по-умолчанию JS возьмёт текущую дату и время из системы.
// ? Также в круглые скобки мы можем передать дату в виде строки, чаще всего это используется, когда у нас есть <input type="date">
console.log(now);

console.log(' ');

const oldDate = new Date(2023, 7, 2, 20); 

console.log(oldDate); // интересный момент, что если запустить код например в VSCode, то покажет 2023-08-02T17:00:00.000Z, хотя в Firefox: Wed Aug 02 2023 20:00:00 GMT+0300.
// Всё дело в том, что изначально месяцы начинаются с 0, а время считается по Гринвичу (GMT 0). Но Firefox и исправляет время на актуальное.
console.log(' ');
// ? Кроме строки и прямых аргументов можно также передать миллисекунды, которые также будут превращены в дату. Дело в том, что любая дата в JS на самом деле хранится в миллисекундах. Значит любую дату можно трансформировать в миллисекунды и наоборот. Это значение ещё называют timestamp. 
// Причём количество миллисекунд отсчитывается от 01.01.1970. (Счет в секундах от 1 января 1970 года распространился благодаря операционной системе UNIX, одной из основных платформ для интернет-узлов. Ее разработка велась с начала 1970-х, и за отправную точку была принята ближайшая круглая дата, а более ранние выражаются отрицательными числами.)

const zeroDate = new Date(0);

console.log(zeroDate); // получим 1970-01-01

console.log(' ');
// ? Кстати, чтобы получить дату до 1 января 1970 нужно использовать отрицательное значение в миллисекундах.

// * ==| Методы Date |== *

const date = new Date();

// Здесь будут рассмотрены не все, т.к. их довольно много, остальные методы можно найти по ссылке внизу.

// * Методы получения компонентов даты (геттеры) *

console.log('Year: ' + date.getFullYear()); // получаем текущий год
console.log('Month: ' + date.getMonth()); // получаем текущий месяц (помним про отсчёт месяцев с 0)
console.log('Date: ' + date.getDate()); // получаем текущее число (дни месяца исчисляются от 1)
console.log('Hour: ' + date.getHours()); // получаем текущий час
console.log('Minutes: ' + date.getMinutes()); // получаем текущие минут
console.log('Seconds: ' + date.getSeconds()); // получаем текущие секунды
console.log('Milliseconds: ' + date.getMilliseconds()); // получаем текущие миллисекунды
console.log('Number of a Weekday: ' + date.getDay()); // получаем номер дня недели (причём нумерация начинается с воскресенья и с 0)

// Также есть специальная разновидность методов, на случай, если понадобится часовой пояс, отличный от нашего.
console.log('Greenwich Hour: ' + date.getUTCHours()); // получаем текущий час по Гринвичу (GMT 0)
// * Есть ещё два специальных метода для получения компонентов даты, отличные от предыдущих
console.log('Timestamp: ' + date.getTime()); // получаем timestamp, или количество всех миллисекунд с начала исчисления, т.е. с полночи 1970-01-01. И это значение можно трансформировать в дату, если подставить в круглые скобки Date(), что иногда и применяется на практике.
console.log('A difference in minutes between our time and UTC: ' + date.getTimezoneOffset()); // получаем разницу между нашим часовым поясом и UTC (в минутах)

console.log(' ');

// * Методы записи компонентов даты (сеттеры) *
// ? По сути те же методы, но приставка get меняется на set. Ну кроме getTimezoneOffset().
console.log(date.setHours(18)); // установим часы. 
// ? Кстати следующим аргументом возможно установить и минуты и секунды, но делать так не рекомендуется из-за неочевидности. Это может сбить с толку других программистов.
// ? Также, если мы установим значение часов больше 24, то JS сам себя скорректирует добавив в дату один или другое необходимое количество дней, а разницу запишет в часы.
console.log(date);

console.log(' ');

// * При работе с датой следует также знать ещё пару вещей, например метод parse(), который также работает с датой
const someDate = new Date('2023-08-17');
// Альтернативно можно установить дату следующим образом:
// new Date.parse('2023-08-17');

// * И наконец даты можно использовать для измерения каких-то промежутков времени.
// Для этого у нас есть timestamps. Их можно использовать как напрямую, так и использовать преобразование динамически типов данных и поставить унарный плюс перед объектов Date.
// Опишем это в классическом приёме:
const start = new Date(); // время начала работы скрипта
// Далее будет выполняться какое-то действие и мы, например, хотим засечь время его выполнения.
for (let index = 0; index < 100000; index++) {
  let element = index ** 3; // возводим index в степень 3 на каждой итерации цикла.
}
// Засекаем время
let end = new Date(); // время окончания работы скрипта
// Высчитываем разницу
console.log(`Время выполнения цикла "for": ${end - start} миллисекунд. Или ${(end - start) / 1000} секунд.`);
// ? Ещё это называют бенчмарки, тесты производительности какого-то скрипта и выглядят они сложнее этого примера, но идея всё так же.
// |===:===:===:===>
/** links:
 * (Документация по Date): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date
 * (Статья про Date): https://learn.javascript.ru/date
 * */