'use strict';

// * === Прочие полезные методы объектов === * \\

// * 1. preventExtensions() - предотвращает добавление новых свойств объекту, т.е. предотвращает расширение объекта в будущем - ничего больше не добавить!
const object1 = {
  name: 'Alex',
  surname: 'Smith',
};

Object.preventExtensions(object1);

// * 2. seal() - «запечатывает» объект, т.е. предотвращает удаление свойств объекта другим кодом. По сути устанавливает у всех свойств объекта configurable: false. Однако флаг writable не затрагивается, поэтому изменять их значение всё таки можно.

const object2 = {
  name: 'Alex',
  surname: 'Smith',
};

Object.seal(object2);

// * 3. freeze() - «замораживает» объект, работает также, как и seal, но здесь даже изменять значения становится невозможным, т.е. добавляет всем свойствам также и writable: false.

const object3 = {
  name: 'Alex',
  surname: 'Smith',
};

Object.freeze(object3);

// * 4. isExtensible() - проверка объекта, можно ли его расширять, т.е. не применялся ли до этого метод preventExtensions на этот объект.

const object4 = {
  name: 'Alex',
  surname: 'Smith',
};

Object.isExtensible(object4);

// * 5. isFrozen() - проверка объекта, был ли объект заморожен, т.е. не применялся ли до этого метод freeze на этот объект.

const object5 = {
  name: 'Alex',
  surname: 'Smith',
};

Object.isExtensible(object5);

// * 6. isSealed() - проверка объекта, был ли объект заморожен, т.е. не применялся ли до этого метод seal на этот объект.

const object6 = {
  name: 'Alex',
  surname: 'Smith',
};

Object.isExtensible(object6);

// ? Хотя перечисленные методы используются на практике довольно редко, но всё же некоторые задачи могут помочь решить.

// |==/—/===/—/==|

// * 7. is() - определяет, являются ли два значения различимыми (то есть, одинаковыми).
// Вспоминаем, что один объект никогда не равен другому, даже если их содержимое одинаково. (*ссылочная система присвоения) А этот метод как раз позволяет сравнивать содержимое объектов.
// ? Иногда он попадается на собеседованиях.

// |==/—/===/—/==|

// Следующие методы будут использоваться довольно часто в практике. Все они позволяют сформировать разного вида массивы из объектов.

// * 8. keys() - возвращает массив из собственных перечисляемых свойств переданного объекта, в том же порядке, в котором они бы находились циклом for ... in (разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов).
const fruits = {
  apricots: 15,
  peach: 8,
  apples: 10,
  sweetCherry: 35,
  watermelon: null
};

console.log(Object.keys(fruits));

// * 9. values() - возвращает массив из собственных перечисляемых значений свойств переданного объекта, в том же порядке, в котором они бы находились циклом for ... in (разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов).
console.log(Object.values(fruits));
// ? * Такое часто применяется например в рекурсии.

// * 10. entries() - возвращает массив из собственных перечисляемых свойств переданного объекта в формате [key, value], в том же порядке, в котором они бы находились циклом for ... in (разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов). Порядок элементов в массиве который возвращается Object.entries() не зависит от того как объект объявлен. Если существует необходимость в определённом порядке, то массив должен быть отсортирован до вызова метода, например Object.entries(obj).sort((a, b) => a[0] - b[0]);
console.log(Object.entries(fruits).sort((a, b) => a[0] - b[0]));

// |===:===:===:===>
// ? Перед собеседованием лучше повторить табличку, т.к. могут реально спрашивать про эти методы.
// links: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object