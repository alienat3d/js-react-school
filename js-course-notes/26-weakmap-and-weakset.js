'use strict';

// * === () WeakMap и WeakSet === * \\
// ? *** Эти темы напрямую связаны с уроками про «сборщики мусора» и про «Map()» и «Set()».
// * Эти структуры используются ещё реже, чем Map() или Set(), и, в основном, для оптимизации кода.
let user = {
  name: 'Ivan',
};
const array = [user];

user = null;
// Если в какой-то момент объекту будет присвоен null, т.е. это будет означать, что там больше ничего не содержится. Всё, объект теперь удалён из памяти, т.к. на него нету ссылок. Это правильное поведение. Но если мы создадим ещё массив array, а в него запишем объект user. Он будет передаваться по ссылочной системе.
console.log(user); // здесь получаем null
console.log(array[0]); // а здесь наш объект остался, точнее ссылка на него, а значит он всё ещё хранится в памяти. А значит, пока массив array существует, то и объект user будет существовать в памяти, не смотря на то, что других ссылок на него нет.
// Тоже самое будет, если использовать карту - Map(). Пока есть карта, до тех пор и объект будет лежать в памяти. Иногда это очень невыгодно. Напишем пример:
let userName = {
  name: 'Aleksey',
};

let map = new Map();

map.set(userName, 'data');
userName = null;

// И здесь у нас точно такая же ситуация, значение в переменной userName мы обнулили, но ссылка на объект осталась внутри карты. И пока существует карта, будет существовать и объект в памяти.
console.log(map.keys());
// * ==| И тут мы переходим к Weakmap. |==
// ? У неё есть две особенности: 1) у неё ключами могут быть только лишь объекты; 2) если нет ссылки на этот объект и он существует только в Weakmap(), то этот объект будет удалён «сборщиком мусора».
let uName = {
  name: 'Al',
};

let weakMap = new WeakMap();

weakMap.set(uName, 'data');
uName = null;
// Проверим существует ли объект uName в нашей "слабой карте" и получим false. Значит он был удалён автоматически «сборщиком мусора».
console.log(weakMap.has(uName));
console.log(weakMap); // получим довольно странный результат
console.log(' ');
// Дело в том, что WeakMap() это такая динамическая структура, которая как бы говорит «сборщику мусора», что если на данный объект нет ссылок, то можно удалить его также и из неё. Но т.к. мы не можем определить, когда «сборщик мусора» будет очищать память, то интерпретатор выводит, что условно "в данный момент времени не возможно определить что же находится внутри этой структуры данных и в каком количестве". И чтобы с технической стороны не возникало ошибок, то мы и не можем как следует рассмотреть эту структуру данных.
// ? Отсюда возникают и некоторые ограничения при работе с WeakMap(), нет таких методов, как: keys(), values(), entries(). Тоже самое и с forof(). Однако доступны set(), get(), delete() и has(). Т.е. нужны определённые условия, чтобы использовать такую структуру. Например временное хранилище объектов сайта или приложения, либо кэширование данных.
// * ==| Пример с чатами. |== *
// Представим, что у нас есть какой-то чат. В одной комнате могут сидеть десятки тысяч людей. Нам нужно всех их сохранить для отображения. При этом кто-то входит, кто-то выходит и всё это необходимо тоже отслеживать. Чаще всего нас интересуют именно те пользователи, которые онлайн, чтобы отслеживать их действия. Офлайн-юзеры отсеиваются. Тут отлично подойдёт WeakMap().
let cache = new WeakMap();
// Создадим функцию, которая будет кэшировать пользователей. Если юзер будет заходить в чат, то он кэшируется, т.е. запоминается в структуре данных. А если этот юзер выйдет из чата, то он будет автоматически удаляться из памяти.
// Напишем условие, что если у нас ещё нет такого пользователя внутри WeakMap(), то будем его добавлять с указанием времени, когда он зашёл, с помощью команды Date.now().
// Ну и в конце вернём этого юзера из функции с помощью get(). Итак не важно, если пользователь уже закэширован, то мы его получим, а если не закэширован, то мы его туда запишем, а потом всё равно получим.
function cacheUser(user) {
  if (!cache.has(user)) {
    cache.set(user, Date.now());
  }

  return cache.get(user);
}
// Ну если мы будем работать с какими-то пользователями, то создадим каких-то из них:
let lena = { name: 'Elena' };
let alex = { name: 'Alexander' };
// Оба пользователя зашли в чат, поэтому используем функцию cacheUser().
cacheUser(lena);
cacheUser(alex);
// Затем Лена вышла из чата.
lena = null; // И как мы знаем, если переменная обнулена и существовала только внутри WeakMap(), то объект будет также удалён из памяти.
console.log(cache.has(lena));
console.log(cache.has(alex));
console.log(' ');
// * ==| WeakSet() |== *
// Очень похожа по своим особенностям на WeakMap().
// ? WeakSet() аналогичен сущности Set(), но мы можем добавлять туда только объекты. Также объект присутствует в множестве только до тех пор, пока он где-то доступен ещё, аналогично WeakMap(). Поддерживает методы add(), has() и delete(). У него нету таких методов, как size, keys(), а также не является перебираемым. Также нету и метода get(). weakSet() также как и WeakMap() это динамическая структура, которая может быстро очищаться «сборщиком мусора» и потому ограничена всего тремя методами.
// * Рассмотрим типичный пример с сообщениями в чате:
// Создадим массив с объектами в переменной для сообщений чата.
let messages = [
  { text: 'Hello', from: 'John' },
  { text: 'Hi', from: 'Jenny' },
  { text: 'Sup?', from: 'Jester' },
];
// Создадим новую структуру данных в переменной readMessages
let readMessages = new WeakSet();
// При работе с чатом какие-то из сообщений будут прочитаны. И в наш WeakSet будут добавлены эти сообщения.
readMessages.add(messages[0]);
readMessages.add(messages[2]);
// Теперь первое и последнее сообщения будут помечены как прочитанные и если мы зайдём ещё раз в чат и увидим эти сообщения, то мы их не сможем ещё раз пометить как прочитанные, ведь это не логично. 
// И теперь, если мы попытаемся снова добавить первое сообщение, то оно будет проигнорировано, т.к. WeakSet() аналогичен в этом смысле обычному Set() и в нём могут хранится лишь уникальные объекты.
readMessages.add(messages[0]); // ничего не изменит

console.log(readMessages);
console.log(readMessages.has(messages[0]));
// А теперь протестируем главное отличие WeakSet() от Set() и удалим из массива messages первый объект-сообщение с помощью метода массивов shift().
messages.shift()
console.log(readMessages.has(messages[0]));
// ? Минус этой структуры данных в том, что мы не можем ни перебрать её, ни узнать какие там сообщения содержатся, как и не можем получить все прочитанные сообщения напрямую, или какое-то одно сообщение. Мы можем лишь проверить, есть ли там это сообщение или нет, добавить или удалить. Не совсем удобно, но в отдельных ситуациях может очень пригодится.

// * Вывод: WeakMap() & WeakSet() - по сути являются дополнительными хранилищами для объектов, управляемых из других мест в коде. В обоих мы работаем только (!) с объектами и если на них нет ссылок на их содержимое, то оно будет удалено из памяти «сборщиком мусора».
// |===:===:===:===>
/** links:
 *  https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap
 *  https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakSet
 * */
