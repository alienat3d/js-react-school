'use strict';

// * === "Живые" или динамические коллекции === * \\

const boxesQuery = document.querySelectorAll('.box');
const boxesGet = document.getElementsByClassName('box');

// console.log(boxesQuery); // список DOM-узлов, также псевдо-массив, но обладает куда более расширенным функционалом, чем следующие за ним псевдо-массивы. (неживая\статическая коллекция)
// console.log(boxesGet); // HTML-коллекция (динамическая\живая)
// console.log(document.body.children); // тоже HTML-коллекция (динамическая\живая)

// * У таких псевдо-массивов или коллекций есть два принципиально отличающихся вида, динамические "живые" и статические "неживые" коллекции.

// boxesQuery[0].remove();
// boxesGet[0].remove();

// По-факту у нас в вёрстке остался только один элемент с классом "box".
// console.log(boxesQuery); // Однако статическая "неживая" коллекция покажет нам и ссылки на удалённые элементы, т.е. псевдо-массив на состояние, когда мы его получили.
// console.log(boxesGet); // А вот динамическая "живая" коллекция уже покажет нам только 1 элемент с классом "box", т.е. текущее состояние.

// ? В подавляющем большинстве случаев нам будет удобнее использовать метод querySelectorAll и использовать статические\неживые коллекции, благодаря расширенному функционалу. И всё же бывают иногда случаи, когда может быть удобно использовать "живую коллекцию", чтобы динамично следить за состоянием DOM-дерева.
// * Но так как с "живых коллекциях" у нас нет методов, способных манипулировать этими псевдо-массивами, то при работе с ними уже приходится применять различные техники, одна из них это создать массив из массивоподобной сущности.
// console.log(Array.from(boxesGet));
// Теперь boxesGet содержит обычный массив, со всеми присущими массивам методами и свойствами. Правда этот массив уже будет статичным, который не следит за изменениями в DOM-дереве, как это делала "живая коллекция".
// Такой приём стоит применять тогда, когда нужно отследить все изменения, которые произошли с элементами к каком-то промежутке времени.
// /==|==/
// Рассмотрим ещё одну ситуацию, в которой новички довольно часто допускают ошибки.
// Для этого получим ещё раз псевдо-массив в другую переменную
const staticCollection = document.querySelectorAll('.box');
const dynamicCollection = document.getElementsByClassName('box');

/* staticCollection[0].remove();

for (let index = 0; index < 5; index++) {
  const div = document.createElement('div');
  div.classList.add('box');
  // document.body.append(div);
  // Новички иногда ошибочно думают, что можно взять живую коллекцию, точнее обратиться к последнему элементу внутри него и записать туда какой-то элемент.
  // dynamicCollection[dynamicCollection.length] = div; - конечно же мы здесь получим ошибку, т.к. напрямую так работать с живой коллекцией нельзя.
} */

// console.log(staticCollection);
// console.log(dynamicCollection);

// |==/—/===/—/==|

// * ==| Метод matches() |==
// Иногда может быть задача, в которой среди всех элементов найти только тот, который подходит по определённым параметрам. А именно по CSS-селектору.
staticCollection.forEach(box => {
  // Если речь шла чётко про классы, то можно было бы воспользоваться box.classList.contains(''), но если нам нужно определить именно селектор, т.е. не обязательно класс. Может быть тег, атрибут или id, например. Тогда нам подойдёт метод matches(). Удобный, широко применяемый метод, который применяется на DOM-элементах.
  if (box.matches('#this')) console.log('Нашёлся!');
});

// * ==| Метод closest() |==
// В вёрстке у нас помимо div'ов с классом ".box", также есть некая обёртка с классом ".wrapper". Так вот мы можем получить обёртку прямо изнутри.
// Обратимся к уже полученной статической коллекции к её первому элементу, а дальше говорим JS найти первый элемент с заданным селектором, который будет являться родителем этого элемента.
console.log(staticCollection[0].closest('.wrapper')); // Т.е. он будет искать по всех цепочке родителей наверх искать элемент с заданным селектором.
// ? Это полезно, когда у нас длинная разветвлённая вёрстка, допустим, с разными модальными окнами, и при клике на кнопку можно получить какую-то обёртку этого модального окна.

// |===:===:===:===>
// links: https://htmlacademy.ru/blog/js/collections-js
