'use strict';

// * === Классы в ES6 === * \\
// ? A.k.a. "синтаксический сахар" для функций-конструкторов.

// Очень часто при создании сайтов используется какая-то шаблонизация. Вместо того, чтобы каждый раз снова и снова создавать какой-то слайдер или какую-то статью, её полностью описывать - все её свойства, методы и т.п., мы создаём один шаблон, который опишет в общих чертах что будет делать этот компонент. Затем уже из этого шаблона создаём отдельные экземпляры, которые будут помещаться на сайт. Таким образом используя лишь один участок кода мы сможем создать сколь угодно компонентов на сайте, которые будут отличаться.

// * 1.0 Синтаксис Класса. Начинается со слова "class" и название всегда с большой буквы. Далее идут {}, внутри которых указываем что должно включать в этот шаблон, что будет уметь делать этот класс и какие свойства будут в нём изначально и т.п.
// * 1.1 При том самый важный параметр это те аргументы, что будут предаваться в класс из-вне, они будут кастомизировать этот элемент. Для этого есть такое слово как constructor. И в () мы запишем те аргументы, которые будут в этот класс приходить.
// 1.2 Допустим у прямоугольника будет высота и ширина width & height.
// 1.3 Теперь с помощью такого класса (шаблона) мы можем сконструировать сколь угодно прямоугольников с разными параметрами ширины и высоты.
// 1.4 После того, как мы обозначили аргументы, нам необходимо записать их также в свойства нового объекта. Если мы напишем ключевое слово "this", то мы будем обращаться к новому экземпляру созданного объекта. (в нашем случае к каждому отдельному прямоугольнику)
// ? Вспомним, что классы также как и конструкторы служат для создания новых объектов.
// 1.5 Добавим также метод calcArea() для расчёта площади прямоугольника. Т.к. он должен возвращать площадь прямоугольника, то напишем return и функцию.
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  calcArea() {
    return this.width * this.height;
  }
}
// 1.6 Теперь можем использовать на класс где в () укажем через запятую ширину и высоту наших геометрических фигур.
const square = new Rectangle(10, 10);
const rect = new Rectangle(50, 20);

console.log(square.calcArea());
console.log(rect);
console.log(rect.calcArea());

// ===:===:===:===:===||===:===:===:===:===

// * 2.0 Вспомним принципы ООП.
// ? 2.1 Первый принцип называется «абстракция» — когда мы отделяем концепцию от её экземпляра, т.е. концепция описана в "class ...", т.е. сам шаблон, на основе которого мы что-то будем создавать, а экземпляр это то, что мы создаём при помощи этого шаблона.
// ? 2.2.1 Второй принцип называется «наследование» — способность нашего объекта или класса базироваться на другом объекте или классе. И это также главный механизм для переиспользования какого-то кода. При этом наследственное отношение классов у нас чётко будет определять их иерархию.
// 2.2.2 Пример: представим, что у нас есть главный "class Title" — это шаблон для создания различных статей на нашем сайте. Чуть позже сайт разрастается и тогда появляется уже задача сделать статьи под разными рубриками. И соответственно каждая из статей будет немного как-то кастомизироваться. При этом они останутся прототипами, на основе которых будет что-то создаваться. Однако появится уже иерархия. Сперва у нас будет главный класс, на основе которого будут создаваться все компоненты, потом будет уже распределение по рубрикам, а затем от этих рубрик уже будут создаваться отдельные экземпляры.
// * 2.2.3 Но так как мы хотели бы, чтобы "class ColoredRectangleWithText" перенял все свойства и методы "class Rectangle" и для этого мы используем ключевое слово "extends".
// 2.2.4 Для нового под-класса нам также понадобятся аргументы ширины и высоты. А также новые аргументы текст и цвет фона.
// 2.2.5 Теперь, чтобы не прописывать "this.width = width;" и другие свойства и методы главного класса, ведь их может быть очень много, у нас есть специальный метод super().
// ? 2.2.6 super() вызовет супер-конструктор родителя или другими словами всё наполнения родителя. И здесь есть важное правило, он всегда (!!!) должен быть на первом месте в конструкторе. Также в () мы можем указать те свойства, которые хотим использовать, т.е. ширину и высоту. Ведь нам не всегда нужны все свойства.
// 2.2.7 Ну а дальше пропишем другие свойства, а также новый метод, чтобы можно было протестировать в консоли.
// todo [ ... продолжение кода от Ln31. ]
class ColoredRectangleWithText extends Rectangle {
  constructor(width, height, text, bgColor) {
    super(width, height);
    this.text = text;
    this.bgColor = bgColor;
  }

  showMyProps() {
    console.log(`Текст: ${this.text}, цвет: ${this.bgColor}`);
  }
}

const div = new ColoredRectangleWithText(25, 10, 'Hello World!', 'green');

div.showMyProps();
console.log(div.calcArea());

// |===:===:===:===>
/** links:
 *  (Документация по JS-классам): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes
 *  (Статья по классам): http://jsraccoon.ru/es6-classes
 * */
