'use strict';

// * === Rest-оператор и параметры по умолчанию (ES6) === * \\
// С оператором «разворота» или spread-оператором мы уже ознакомились, а rest-оператор можно сказать его брат, использующий точно такой же синтаксис, но уже в других условиях.
// * Если spread-оператор брал сущность и раскладывал её на отдельные элементы, то rest-оператор занимается обратным — он отдельные элементы объединяет в один массив. 
// 1.0 Причём уже в названии оператора стоит "оставшиеся" элементы и оно оправданно. А вот так это выглядит на практике:
// 1.1.0 Представим, что у нас есть функция, которая выводит что-то в консоль и принимает аргументы a, b, а дальше мы не знаем сколько последующих аргументов у нас может быть. Может быть 20, а может ни одного.
// 1.1.1 Например мы хотим добавить классы к элементу на странице. Мы знаем чётко, что там будут классы item и menu, а остальные будут опциональными. Они могут быть, а могут и не быть. Но самое главное, что они тоже приходят в виде аргументов функции.
// 1.1.2 Или более конкретный пример: представим, что у нас есть программа, которая рассчитывает различные бюджеты, например семейные. И у нас есть обязательные атрибуты такие как з\п мужа, з\п жены, а далее идут различные подработки, выигрыши, проценты с инвестиций и т.п. опциональные деньги, которые могут быть, а могут и не быть. И после фиксированных атрибутов нужно что-то, что будет это контролировать. Этим и будет rest-оператор.
// ? rest-оператор или "..." записывается всегда последним. Сперва идут обязательные аргументы, а за ними rest-оператор, который указывает на то, что может быть любое количество каких-то элементов. Назвать его можно как угодно. Он соберёт всё оставшееся и сформирует из этого массив.
const log = function (a, b, ...rest) {
  console.log(a, b, rest);
};

log('яблоки', 'груши', 'вишня', 'арбуз');

// * 1.2 Иногда нам требуется, чтобы параметры в наших функциях по умолчанию имели какие-то значения. Как пример возьмём простейшую функцию, где если мы укажем два параметра, то они будут перемножаться, но если только один, то оно удвоится.
function calcOrDouble(number, basis = 2) {
  // basis = basis || 2; // ? До стандарта ES6 использовался такой лайфхак с оператором "или", т.к. "или" возвращает первое значение true, то если бы мы не указали basis, то он был бы undefined, а значит false и вернулось бы 2.
  console.log(number * basis);
}

calcOrDouble(20, 10);

// |===:===:===:===>
/** links:
 *  (rest): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Rest_parameters
 *  (Параметры по умолчанию): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Default_parameters
 * */
