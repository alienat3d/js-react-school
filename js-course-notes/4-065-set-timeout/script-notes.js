'use strict';

// * === setTimeout() - выполнение по таймеру (part 1) === * \\

// * Позволяет выполнить любую операцию по истечению времени, которое мы указываем в миллисекундах после функции через запятую.
// Помимо этого данная конструкция может принимать аргументы, которые будут аргументами для функции внутри. Хотя это используется не часто, но знать нужно и аргументом может быть множество. Помимо этого можно даже передавать готовую функцию.
const timerID = setTimeout((text) => console.log(text), 2000, 'Hello');

// * Либо мы могли бы создать функцию, выводящую текст "text" в консоль, потом сделать таймер на 3 секунды, который вызовет эту функцию.
const logger = () => console.log('text');
// ? Кстати можно и без переменной записать setTimeout() и он тоже сработает.
setTimeout(logger, 3000);

// ? Но зачем же мы тогда определяли таймер в переменную? Дело в том, что мы записываем числовой идентификатор этого таймера.
// Представьте, что вы зашли в магазин часов и нам нужны определённые часы, те, которые нам понравились, мы их упакуем в коробку и здесь происходит всё примерно также. Мы конкретный таймер помечаем собственным уникальным ID и помещаем в переменную. Делается для того, чтобы мы могли различать наши таймеры, ведь таких асинхронных функций может появиться очень много. Определять с помощью ID их нужно, чтобы мочь их потом останавливать.

// Практический пример: Когда пользователь зашёл на сайт, то у него включается такой вот таймер и через 30 секунд ему покажут модальное окно. Но если он кликнет на какую-то кнопку, например "купить товар", то таймер должен сброситься. Ему не нужно показывать модальное окно, ведь пользователь и так уже сделал то, что хотел от него хозяин сайта.
// ? Сбрасывается таймер с помощью команды clearInterval()

clearInterval(timerID); // Теперь таймер в переменной "timerID" будет сброшен и больше не запустится.

// * ==| setInterval() - повторение по кругу через интервал |== *
// Выглядит также и получает аргументы такие же, как и setTimeout().

// * Перейдём к практике с вёрсткой:
const button = document.querySelector('.btn');
// Чтобы отменять переменную timer вне callback-функции addEventListener, нужно сперва создать её вне этой функции снаружи.
// Чтобы наш clearInterval() работал правильно нам нужна ещё переменная-итератор (счётчик), иначе он будет получать лишь undefined, т.к. идёт в потоке синхронного кода, ведь только после клика у нас срабатывает функция, но clearInterval() лежит вне обработчика события клика.
let timer,
  iterator = 0;

// Внутри функции мы также отслеживаем сколько раз уже применился интервал.
// А также поставим условие, чтобы интервал сработал лишь 3 раза, а потом останавливал этот бесконечный цикл.
const logging = () => {
  if (iterator === 3) {
    clearInterval(timer);
  }
  console.log('Logging Text...');
  iterator++;
};

button.addEventListener('click', () => (timer = setInterval(logging, 2000)));
// * |===:===:===:==| *

// ? Когда-нибудь, если вас спросят чем рекурсивный setTimeout() лучше, чем setInterval()?
// * Сначала напомним, что такое рекурсия - это когда функция сама себя внутри вызывает.
// И в принципе setTimeout() внутри себя также может вызвать ещё один setTimeout(). Т.е. когда закончится внешний таймер запустится внутренний и т.д. И здесь мы встретимся с проблемой, что когда таймер с интервалом работает, он не учитывает то, как долго будет работать функция внутри него. Имеется в виду именно setInterval(). Ему всё равно сколько будет выполнятся функция внутри него. Но если так случится, что функция внутри будет тяжёлой, ресурсоёмкой и потребует больше времени на своё выполнение, чем таймер setInterval(), то он не будет ждать свой таймер, а будет думать, что его таймер уже прошёл во время выполнения функции и сразу запустит следующий вызов функции. Вот, чтобы таких казусов не случалось, то используют рекурсивный вызов setTimeout().
// * Напишем к этому пример:
let id = setTimeout(function logText() {
  console.log('Hello World!');

  id = setTimeout(logText, 500);
}, 500);
// Да, действительно работает как и setInterval(), но с той разницей, что этот код будет всегда ждать строго отведённое ему время. Теперь какой бы объёмный код внутри не был, он дождётся завершения операции, потом подождёт строго свои 500 миллисекунд и уже потом запустит снова эту функцию logText(). Т.ч. такой проблемы уже точно не будет.
// |===:===:===:===>
/** links:
 * (Статья про JS-анимации): https://learn.javascript.ru/js-animation
 * */
