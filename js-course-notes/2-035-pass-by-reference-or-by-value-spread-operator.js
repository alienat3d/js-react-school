'use strict';

// |==/—/===/—/==| Передача данных по ссылке и по значению |==/—/===/—/==|

let a = 5,
  b = a; // ? Копия!

b = b + 5;

console.log(b);
console.log(a);
// |==/——/==|
const obj = {
  a: 5,
  b: 1,
};
// Теперь создадим переменную, в которую мы поместим как бы копию объекта. И мы предполагаем, что это сработает также, как и с предыдущим вариантом. Попробуем переназначить значение элемента с ключом a с 5 на 10.
const copyObj = obj; // ? Ссылка!

copyObj.a = 10;
// Посмотрим, что же получилось?
console.log(copyObj);
console.log(obj);
// * Хм, странная вещь, получается изменяя копию мы изменили также наш исходны объект obj? Почему же так выходит?
// ? Дело всё в том, что когда мы работаем с примитивными типами данных, типа строк, чисел, логических значений, то они передаются по значению. То есть выше переменной b мы на самом деле присвоили значение a и она стала копией a, поэтому дальнейшие изменения на a никак не влияют.
// ? Но вот когда мы имеем дело с объектами, массивами, функциями и специфическими объектами, типа Data, то у нас уже идёт передача не по значению, а по ссылке. То есть в действительности это на самом деле не копия объекта, а ссылка на него. Поэтому когда мы попробуем изменить элемент нового объекта, то и этот же элемент исходника поменяется, ведь в новом объекте всё ссылается на исходник.
// |==/——/==|
// * Так как же нам теперь создавать копии объектов, массивов и всего другого, что передаётся также по ссылке? Для этого существуют несколько способов и они будут описаны ниже.

// Первое — это использование цикла. Создадим функцию, которая будет при помощи цикла она создаст новый объект, перебирая старые свойства, которые были в нашем объекте.
function copy(mainObj) {
  let objCopy = {};
  // Создаём перебирающий цикл for in. Кстати переменную key можно создавать и вне цикла.
  let key;
  // Укажем, что у нас в передаваемом в аргумент функции выше объекте mainObj есть ключи key. Внутри указываем наш новый объект, куда будем копировать и также свойство ключей в [] и делаем копию нашего объекта.
  // В итоге мы пройдёмся по передаваемому в функцию объекту скопируем все свойства которые там есть и поместим их в нашу новую копию objCopy, которая изначально была новым пустым объектом.
  for (key in mainObj) {
    objCopy[key] = mainObj[key];
  }
  // Ну и чтобы иметь возможность потом работать с нашим новым объектом, возвращаем его наружу.
  return objCopy;
}
// Протестируем эту функцию на чём-то реальном
const numbers = {
  a: 2,
  b: 5,
  c: {
    x: 7,
    y: 4,
  },
};
// Теперь мы можем скопировать этот объект в newNumbers.
const newNumbers = copy(numbers);

// console.log(newNumbers);
// И вот теперь уже произошло клонирование объектов, благодаря циклу, что мы подготовили заранее. Теперь numbers & newNumbers на первый взгляд мы имеем независимые объекты.
newNumbers.a = 10;
// Однако, если мы обратимся к вложенности объекта с и захотим поменять x на 10, то обнаружим, что х поменялось также в обоих объектах. Почему же так происходит?
// ? Когда мы клонируем объект, есть два понятия: глубокие и поверхностные копии объекта. Выше мы создали поверхностную копию объекта, взяли только обычные свойства родителя и создали как бы независимую структуру на первом уровне, но как только в нём будет вложен ещё один объект, или массив, или ещё какая-то подобная сущность, то внутри такой сущности свойства будут иметь опять ссылочную передачу данных.
// Позже мы будем создавать также и глубокое клонирование объектов, создавая полностью независимые друг от друга копии.
newNumbers.c.x = 10;

console.log(newNumbers);
console.log(numbers);
// |==/——/==|
// Второй способ создать копию - Object.assign(). У глобального объекта Object есть метод, который поможет соединить сразу несколько объектов.
// Допустим есть один большой объект и мы хотим внутрь поместить какой-то объект поменьше, у которого внутри также будет несколько свойств.
const albertBio = {
  age: 20,
  height: 170,
  weight: 70,
  isMarried: false,
  occupation: 'student',
  university: 'Cambridge',
};

const albertsFriends = {
  friends: {
    jack: {
      age: 20,
      height: 190,
      weight: 100,
      isMarried: false,
      occupation: 'student',
      university: 'Cambridge',
    },
    lisa: {
      age: 22,
      height: 165,
      weight: 50,
      isMarried: false,
      occupation: 'student',
      university: 'Cambridge',
    },
    suzanne: {
      age: 19,
      height: 178,
      weight: 78,
      isMarried: true,
      occupation: 'waitress',
      university: null,
    },
  },
};

// Теперь объединим эти два объекта albertBio & albertsFriends в один объект. Первым аргументом будет объект в который мы хотим поместить все данные, а вторым тот объект, который мы будем присоединять.
console.log(Object.assign(albertBio, albertsFriends));

// ? И это у нас опять же будет квази независимый объект поверхностного клонирования, как и в предыдущем случае.

// * Тоже самое мы могли бы сделать и с пустым объектом, чтобы создать копию объекта.
const albertsFriendsClone = Object.assign({}, albertsFriends);

albertsFriendsClone.friends = null;
console.log(albertsFriendsClone);

// |==/——/==|
// * Рассмотрим частный случай объектов - массив. Чтобы создать копию массива мы конечно могли бы воспользоваться каким-то циклом и написать для этой цели функцию. Но также есть специальный метод, чтобы создать копию массива:
const oldArray = ['a', 'b', 'c', 'd'];
// const newArray = oldArray; - Если бы мы написали так, то у нас в newArray был бы не клон, а ссылки на элементы из массива oldArray и если мы начнём изменять элементы из newArray они также изменятся и в oldArray.
// ? Чтобы создать копию используется метод slice().
const newArray = oldArray.slice(); // Позволяет просто скопировать все элементы (если без аргумента), либо какое-то указанное в аргументе их количество.

newArray[1] = 'Hello World!';
console.log(newArray);
console.log(oldArray);

// |==/——/==|
// * Четвёртым способом сделать копию будет, и это уже технологии из ES6+, spread operator или «оператор разворота». Его так назвали, потому что он буквально разворачивает структуру, превращая её в набор каких-то данных. (В ES6 он появился для массивов, а в ES8 уже и для объектов.)
// Теперь нам нужно, чтобы в массиве переменной internet складировались массивы videoHostings & blogHostings, ну и что-то ещё дополнительно. Сделаем это с помощью spread-оператора "...".
const videoHostings = ['YouTube', 'Vimeo', 'Twitch'],
  blogHostings = ['WordPress', 'Live Journal', 'Blogger'],
  internet = [
    ...videoHostings,
    ...blogHostings,
    'HTML Academy',
    'From 0 to 1',
    'Web Standards',
  ];

console.log(internet);

// * Закрепим эти знания примером чуть сложнее.
// Представим, что мы пишем функцию для обработки приходящих с сервера данных о каком-то видео.
function log(name, length, genre) {
  console.log(name);
  console.log(length);
  console.log(genre);
}

const num = ['Batman', '1h 37m 20s', 'Action, Comic'];
// Но так как функция принимает 3 отдельных элемента, а не массив, тут нас как раз выручит spread-оператор.

// log(num); Не сработает, т.к. массив будет лишь одним элементом, а нам нужны 3.
log(...num);
// ? С такой конструкцией придётся работать довольно часто например в react.

const germanCarCompanies = ['BMW', 'VW', 'Mercedes-Benz', 'Porsche'];
const germanCarCompaniesClone = [...germanCarCompanies];
console.log(germanCarCompaniesClone);

// |==/——/==|
// * Пример работы spread-оператора с объектами.
const employees = {
  ceo: 'James Black',
  projectManager: 'Billy Bons',
  leadDeveloper: 'Michael Dreezer',
  webDesigner: 'Julia Singer',
  hrManager: 'Olivia Claw',
  accounter: 'Silvia Santiago',
};

const employeesFull = {...employees};

console.log(employeesFull);

// |===:===:===:===>
/** links:
 * (Документация про Object.assign): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * (Документация про spread-оператор): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Spread_syntax
 * (Статья про клонирование): https://medium.com/@stasonmars/%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-javascript-d25c261a7aff
*/