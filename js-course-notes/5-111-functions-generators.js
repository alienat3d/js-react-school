'use strict';

// * === Функции-генераторы === * \\

// ? 1.0.0 Эти функции генерируют нам какой-то результат и делают это последовательно.

// 1.0.1 Либо так, перед названием функции
// function *generator () {};
// 1.0.2 Либо так, после слова function и это более распространённый вариант
// * 1.1.0 Что значит выдаёт результат последовательно: один раз вызвали функцию — получили один результат. Вызвали ещё раз — получили какой-то другой результат. За этот функционал отвечает ключевое слово yield. Итак, каждый раз, когда мы вызовем эту функцию — она передаст последовательно результат один за другим.
function* generator() {
  yield 'S';
  yield 'c';
  yield 'r';
  yield 'i';
  yield 'p';
  yield 't';
}

const string = generator();
// 1.1.1 Теперь, чтобы вызвать следующий результат из нашей функции-генератора необходимо использовать метод next(). Когда такая функция сработает, то отдаст нам два ключа "value" (само значение) и "done" (сообщает выполнился ли генератор полностью или ещё нет).
// 1.1.2 Как мы видим, когда у генератора закончатся значения "value", то он вернёт нам value: undefined & done: true, что сигнализирует, что генератор дошёл до конца своих значений и завершил генерацию.
// 1.1.3 Чтобы получить сразу значение value просто допишем .value.
console.log(string.next());
console.log(string.next().value);
console.log(string.next());
console.log(string.next());
console.log(string.next());
console.log(string.next());
console.log(string.next());

// * ===:===:===:=== *

// * 1.2.0 Рассмотрим пример посложнее.
// 1.2.1 Очевидно, что прописывать вручную, как на предыдущем примере не слишком хочется, поэтому давайте рассмотрим как этом можно прописать автоматически.
// 1.2.2 Итак, когда мы вызываем функцию count() в неё передаётся какое-то значение, которое передаётся как n и это n является условием цикла for. Здесь особенность работы цикла заключается в том, что он не срабатывает до самого конца, как обычно, а выдаёт только первое значение. Затем ждёт, пока на функцию-генератор снова сработает метод next(), чтобы цикл продолжился на ещё одну итерацию и выдал следующее значение и т.д. до конца работы цикла.
function* count(n) {
  for (let index = 0; index <= n; index++) {
    yield index;
  }
}

/* const counter = count(7);

console.log(counter.next().value);
console.log(counter.next().value);
console.log(counter.next().value);
console.log(counter.next().value);
console.log(counter.next().value); */

// * 1.3.0 Функцию-генератор можно перебрать при помощи конструкции "for of". Вместо того, чтобы каждый раз вызывать функцию методом .next(), можно сделать следующим образом:
// 1.3.1 Итак, если стоит задача запустить функцию-генератор максимальное количество раз, то можно смело запускать конструкцию "for of".
for (const k of count(7)) {
  console.log(k);
}

// |===:===:===:===>
/** links:
 * https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/function*
 * */
