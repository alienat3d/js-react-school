'use strict';

// * === Set() === * \\

// Set() - это особый вид коллекции типа массива, где каждое значение может повторяться только один раз. Или иначе это особый вид массива, где значения не могут повторяться.
const array = [1, 1, 2, 2, 4, 5, 6, 5];

const set = new Set(array);

console.log(set);

console.log(' ');

// * Для примера представим такую ситуация, когда нам из базы данных приходит список студентов на одном курсе. Студент это уникальный человек и одинаковых быть не должно.
// Со строками всё работает также, как и с числами.
const students = [
  'Alex Woods',
  'Alexandra Soltice',
  'James Brown',
  'Danny Godsberg',
  'Alex Woods',
];

const setStudents = new Set(students);

// * ==| Методы Set() |==
// Они очень похожи на методы Map() из предыдущего урока.
// 1) - set.add(value) добавление записи
setStudents.add('Ivan Ivanoff');
setStudents.add('James Brown');
// Также, как и в Map() эта команда возвращает сам набор, а значит мы могли бы записывать и в строку несколько, например: setStudents.add('Ivan Ivanoff').add('James Brown');
console.log(setStudents);

console.log(' ');

// ? Стоит отметить, что похожий функционал можно сделать и в обычном массиве. Перед тем как добавить какое-то новое значение в массив при помощи метода push(), мы можем пройтись по всему массиву и проверить, нет ли ещё такого значения, которое мы хотим добавить. И если его нет, то мы его добавим. Всё это можно было бы реализовать методом find(), что есть у массивов. Он позволяет искать внутри массива какие-то сущности. (подробнее в ссылке ↓)
// Хоть можно это же реализовать и с помощью обычного массива, но Set() будет куда лучше. Во-первых потом, что не придётся писать дополнительную логику ради этого, во-вторых эта структура данных будет более оптимизированной и потому сработает быстрее.

// 2) - set.delete(value) удаление записи
// 3) - set.has(value) проверка наличия записи внутри коллекции
// 4) - set.clear(value) полная очистка от данных внутри коллекции
// 5) - set.size - размер (количество записей) коллекции

// * Также можем перебирать с помощью:
// * "for...of"
for (const value of students) {
  console.log(value);
}

console.log(' ');

// * Другой вариант это использовать forEach().
// Здесь интересная ситуация, т.к. у нас это массивоподобный объект, то здесь у нас одни значения. Т.е. ключи нет смысла получать. Это просто будет порядковый номер. Поэтому вторым аргументом valueAgain, т.е. такой же value, как и в первом аргументе. Это специально сделано, чтобы была совместимость. И конечно есть set\массивоподобный объект на который мы можем ссылаться, как обычно внутри forEach().
setStudents.forEach((value, valueAgain, setStudents) => {
  console.log(value, valueAgain);
});

console.log(' ');

// * Также у нас есть и другие методы, такие же, что были у Map():
// ? Но честно говоря, обычно хватит предыдущих двух методов для перебора данных в наборе Set().
console.log(setStudents.values()); // выводит значения (здесь можно было бы просто for...of использовать без этой команды)
console.log(setStudents.keys()); // этот метод по своей сути существует для обратной совместимости с Map(), ведь ключей в Set() как таковых нет, это порядковые номера. Обе команды вернут одно и то же, коллекцию уникальных записей.
console.log(setStudents.entries()); // этот метод также существует для обратной совместимости с Map().

// * ==| Если ещё говорить о практическом применении Set() как такового, то часто реализуют функцию-помощника, которая фильтрует любой массив. |==
// Давайте посмотрим как это выглядит на примере:
// Создаём функцию, которая будет принимать какой-то массив и возвращать она будет отфильтрованный массив. Создадим Set() с тем массивом, который приходит внутрь функции, в качестве аргумента. Теперь у нас есть набор данных или Set() и мы можем его трансформировать снова в массив, у которого будут те же методы, что и раньше. push(), pop() и др. Т.е. командой Array.from() мы создадим массив из набора данных new Set(array).
// Таким образом мы создали быструю фильтрацию: 1) массив передаётся в Set(), где избавляется от дублирующих друг друга значений, 2) формируем обратно массив, который возвращается из этой функции, но уже с уникальными значениями.
function unique(array) {
  return Array.from(new Set(array));
}
// ? Это классика, которую вы будете встречать повсеместно.new Set(array)
console.log(unique(students));
console.log(unique(array));
// |===:===:===:===>
/** links:
 * https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Set
 * https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * */
