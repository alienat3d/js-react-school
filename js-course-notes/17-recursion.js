'use strict';

// * ===/ Рекурсия /===
// * Это когда внутри функции вызывается эта ж функция, т.е. сама себя.

// https://learn.javascript.ru/recursion

// Рассмотрим классический пример из почти любого учебника программирования. Функция возведения в степень.

// Чтобы написать такую функцию существует два подхода.
// 1)
/* function pow(x, n) {
  let result = 1; // Почему 1? Потому, что если было бы 0, то при умножении на любое число мы всегда будем получать ноль, а это не то, что мы бы хотели получить.
  Далее используем цикл, который закончит действовать, когда итератор i будет меньше степени, которая передаётся.
  for (let i = 0; i < n; i++) {
    result *= x; // *= значит "дополненное умножение", т.е. умножает и присваивает значение одновременно. Тоже самое, что result = x * result;
  }

  return result;
}

console.log(pow(2, 1)); // 2
console.log(pow(2, 2)); // 4
console.log(pow(2, 3)); // 8
console.log(pow(2, 4)); // 16 */

// * 2) Но можно направить мысли и в другое русло. Если у нас функция по возведению в степень, то почему бы нам вместо цикла не запускать её же, пользуясь рекурсией?
function pow(x, n) {
  // debugger;
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
    // debugger; // В случае (2, 3) если вместо х приходит двойка, то получается 2 * на результат 2 в n - 1 степени, то есть 2². 2 * 4 = 8.
  }
}
// Получается, что pow(x, n - 1) вычисляет тоже самое, что и выше pow(x, n), но на 1 степень меньше. И когда у нас будет много степеней, то у нас будет вложенность функций. Одна функция будет внутри себя вызывать другую, другую и другую. До тех пор, пока мы не дойдём до какой-то базовой функции, которая нам вернёт двойку, тоже самое, что мы получили в pow(2, 1). Это и есть рекурсия, когда функция внутри себя себя же запускает.

/* console.log(pow(2, 1)); // 2
console.log(pow(2, 2)); // 4
console.log(pow(2, 3)); // 8
console.log(pow(2, 4)); // 16
console.log(pow(2, 5)); // 32 */
console.log(pow(5, 9)); // 1953125 */

// * Рассмотрим ещё пару терминов, которые могут пригодится.
// ? База рекурсии — в данном примере это и была pow(2, 1), т.е. это тот случай, который приводит сразу к завершению функции. Этот случай (строка 26) приводит к тому, что тут же возвращается значение х. И даже если мы запустим какое-то большое значение, то рекурсия в любом случае придёт к своей базе, потому что n каждый раз снижается на 1.

// ? Шаг рекурсии — это запуск вложенной функции, но уже с другим значением. В данном случае можно заметить, что каждый раз n уменьшается на 1. Это есть шаг рекурсии и можно заметить, что каждый раз

// ? Глубина рекурсии — это общее количество вложенных вызовов вместе с самым первым. Тут у нас это число, которое подставляется в n.
// * Ещё есть такое понятие, как "максимальная глубина рекурсии", но это частный случай глубины рекурсии и означает - насколько максимально может рекурсия нырнуть сама в себя. Она варьируется от сложности действий и возможностей устройства, на котором выполняется код. Но обычно это где-то в районе 10000.

// * Что же из двух подходов лучше использовать?
// * Выбор всегда за разработчиком, но следует помнить о паре нюансов: 1) Итеративный подход, т.е. перебором при помощи цикла, обычно эффективнее. Это связано с внутренним устройством языка и такими вещами, как контексты и стек вызова. Если говорить поверхностно, то можно отметить, что когда функция вызывается внутри функции, то она должна сохранять все эти n, ещё какие-то части сохранять, особенно, если это будет более сложная функция и т.п. В цикле этого нет. 2) Рекурсия на самом деле делает функции проще, хоть и имеет ограничения по глубине, из-за чего код становится несколько более понятным. 3) У каждого свои предпочтения, но большинство программистов всё таки склоняются к рекурсии.

// |==/—/===/—/==|

// * Рассмотрим на примере.

const students = {
  js: [
    {
      name: 'John',
      progress: 100,
    },
    {
      name: 'Ivan',
      progress: 60,
    },
  ],

  html: {
    basic: [
      {
        name: 'Peter',
        progress: 20,
      },
      {
        name: 'Ann',
        progress: 18,
      },
    ],

    pro: [
      {
        name: 'Sam',
        progress: 10,
      },
    ],
    // * Теперь протестируем, как модифицировать код, если данные изменятся и наша структура данных вместе с ними.
    // Добавим ещё свойство, которое уже будет объектом. Итак структура изменилась и итерационный метод уже не сработает, т.к. он был рассчитан на определённую структуру. А вот второй метод рекурсии остался рабочим.
    semiPro: {
      students: [
        {
          name: 'Jack',
          progress: 100,
        },
      ],
    },
  },
};

// Представим, что у нас стоит задача вычисления общего процента прогресса всех студентов всех курсов. Для этого можно использовать два метода, либо цикл, либо рекурсию. Напишем оба варианта и сравним.
// Итак, как же будем считать средний прогресс среди всех студентов? 1) Нужно посчитать общее количество студентов; 2) Посчитать общее число в процентах; 3) Общее число / кол-во студентов.

// Итеративный метод при помощи цикла.
// total - общий прогресс.
// students - общее количество студентов.
// С помощью метода объектов values() получим данные прогресса из каждого свойства. Этот метод возвращает массив значений свойств объекта в том же порядке, что и цикл for...in. Разница между методом и циклом в том, что цикл перечисляет и свойства из цепочки прототипов. Метод однако использовать проще и он делает код лаконичнее.
// Итак, можно сказать, что метод делает из объекта students массив, опуская свойства "js" и "html", а их содержимое становится элементами этого массива. For...of цикл перебирает каждый элемент этого массива, сперва он записывается в course и затем обрабатывается.
// Т.к. у нас в переменной лежит либо массив из свойства "js", либо объект из "html", то тут нам нужна развилка, т.е. условие: Либо мы работает с массивом, либо с объектом. Проверяем массив это или объект.
// * Для такой манипуляции есть ещё один метод Array.isArray(), который возвращает true, если проверяемая сущность является массивом и false, соответственно, если не является.
// Теперь, коль мы попали на массив, то мы должны посчитать количество студентов в массиве. А также сложить свойства progress.
// Перебираем массив и вытаскиваем из каждого свойства progress его значение, а потом складываем их друг с другом. Используем цикл, получаем из массива каждый элемент через его индекс в массиве и обращаемся через точку к свойству, т.к. это объект. Затем прибавляем к значению total.
// Вторая часть (после else) будет отвечать за случай, когда мы не попадаем на массив, т.е. работаем с объектом. Тут мы получаем внутренности свойств "basic" и "pro". Там у нас только массивы, значит даже и проверять на массив не требуется.
function getTotalProgressByIteration(data) {
  let total = 0;
  let students = 0;

  for (const course of Object.values(data)) {
    if (Array.isArray(course)) {
      students += course.length;

      for (let index = 0; index < course.length; index++) {
        total += course[index].progress;
      }
    } else {
      for (const subCourse of Object.values(course)) {
        students += subCourse.length;

        for (let index = 0; index < subCourse.length; index++) {
          total += subCourse[index].progress;
        }
      }
    }
  }

  return total / students;
}

console.log(getTotalProgressByIteration(students));

// * Но что, если, например в свойстве "html" у нас вдруг добавится объект, а не массив, на которые мы ориентировались? Ведь мы ориентировались именно на объект, который будет содержать свойства, содержащие в себе только массивы. В данном случае придётся усложнять функцию. Придётся после else {... писать ещё одну проверку на то, что может прийти ещё массив. Будет очень много вложенностей и они будут повторяться и расширятся. Это может привести к усложнению понимания и многократному повторению кода.
// * Чтобы таких моментов не возникало и можно использовать рекурсию. Рекурсия упростит функцию, т.к. все однотипные действия заключаем в функцию и она уже внутри себя будет каждый раз её вызывать. Рассмотрим это на примере:
// Итак, что будет здесь базой рекурсии? Т.е. тот случай, который заканчивает функцию? Это будет какой-то массив, ведь как только мы наткнёмся на массив данных, то мы уже знаем, что внутри будут объекты со студентами. Значит базой будет условие проверки на массив.
// Сперва проверяем, что data может быть массивом.
// ? Кстати, заметим, что когда прописываем рекурсию, в отличие от циклов нет как таковых промежуточных переменных, потому что они высчитываются на уровне функции и возвращаются в итоговый результат.
// Но всё же мы запишем переменную total, потому что нам всё же придётся вычислить сумму процентов прогресса. А вот общее кол-во студентов мы можем получить через data.length. Потому что, сколько элементов в массиве - столько же и студентов на этом курсе.
function getTotalProgressByRecursion(data) {
  if (Array.isArray(data)) {
    let total = 0;

    for (let index = 0; index < data.length; index++) {
      total += data[index].progress;
    }
    // Теперь вернём два значения из этой функции при помощи массива. По сути там также содержатся всё те же данные, что и в строках 108 и 109 в цикле.
    return [total, data.length];
  } else {
    // Теперь сама рекурсия. Объявляем переменную в которой находится массив с промежуточным результатом.
    let total = [0, 0];
    // При помощи for...of цикла делаем перебор объекта. Т.к. это точно уже объект, мы используем метод для объектов values().
    // ? Т.к. у нас есть какие-то вложенные данные, то мы должны саму же функцию запустить на этих данных. Т.е. мы попадаем на внутреннее свойство объекта students и для каждого этого свойства, либо объекта, либо массива мы заново запускаем эту функцию, которая будет обрабатывать их.
    for (const subData of Object.values(data)) {
      // Т.к. мы уже знаем, что нам вернётся массив (стр. 151), т.к. у нас есть база и в ней массив из двух элементов.
      const subDataArray = getTotalProgressByRecursion(subData); // Теперь тут будет каждый раз запускаться рекурсия до тех пор, пока она не дойдёт до базы, т.е. пока она не наткнётся на конечный массив со всеми студентами зарегистрированными где-то.
      // Итак, мы здесь перебираем и нас интересует конечное значение total, т.е. общая сумма всего прогресса, будем добавлять значения каждого студента от самого первого, т.е. нулевого индекса. А второго элемента массива, количества студентов ко второму (1 индекс).
      total[0] += subDataArray[0];
      total[1] += subDataArray[1];
    }

    return total;
  }
}

const result = getTotalProgressByRecursion(students);
// И так как нам нужно получить результат деления первого значения массива на второе, то сделаем так. Т.е. мы общую сумму прогресса всех студентов делим на общее количество всех студентов.
console.log(result[0] / result[1]);
