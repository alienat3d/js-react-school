'use strict';

// * === classList и делегирование событий === * \\

const buttons = document.querySelectorAll('button');
// Чтобы обратиться к списку классов нужно прописать classList, это свойство, которое есть у этого DOM-узла.
console.log(buttons[0].classList.length); // length покажет количество имеющихся классов у первой кнопки в коллекции.
console.log(buttons[0].classList.item(0)); // item() позволяет нам получить класс, который располагается под определённым индексом.
console.log(buttons[1].classList.add('red')); // добавляет классы (кстати можно передавать несколько классов через запятую)
console.log(buttons[0].classList.remove('blue')); // удаляет классы (кстати можно передавать несколько классов через запятую)
console.log(buttons[0].classList.toggle('blue')); // переключатель, т.е. если класс сейчас есть на элементе, то он будет убран, а если нет, то добавлен

// Кстати, наличие классы мы можем использовать и в условиях. При помощи item() получить какой-то класс и поместить его в условие. Но проблема такого подхода в том, что мы не всегда можем быть уверены, что нужный класс находится на той позиции, что мы укажем в item().
// Чтобы этой неопределённости избежать существует метод contains(). Он позволяет как раз проверять наличие конкретного класса на элементе и вернёт false\true, или булево значение.
if (buttons[1].classList.contains('red')) {
  console.log('Есть такое дело!');
} else {
  console.log('Тут такого класса нет!');
}

// * ==| Реализуем стандартный функционал гамбургер-меню |== *
// По клику на первую кнопку проверяем, что у второй кнопка нет класса "red".
buttons[0].addEventListener('click', () => {
  if (!buttons[1].classList.contains('red')) {
    buttons[1].classList.add('red');
  } else {
    buttons[1].classList.remove('red');
  }

  // Можно в принципе использовать и toggle()
  // buttons[1].classList.toggle('red');
  // ? Если посмотреть под капот JS, то в методе toggle() содержится такая же логическая конструкция, что и выше. Но в сложных скриптах просто использовать toggle() может быть не всегда доступно или уместно. Иногда требуется вручную проверить есть ли какой-то класс.
  // ! Прежде чем прописать скрипты лучше проговорить логическую цепочку, которую хотим сделать !
});

// todo -| УСТАРЕЛО [!] className * |- \\
// Но на всякий случай стоит про него знать. Мало ли придётся отлаживать старый код.
// console.log(buttons[0].className); - получает список классов строкой, что совсем неудобно и поэтому оно устарело.

// * ==| Делегирование событий |== *
// Это также важный приём, который часто используется. Бывает так, что на странице много кнопок и мы хотим, чтобы при клике на любую из них вызывалось одно и то же событие. Мы могли бы конечно повесить на каждую кнопку отдельно, но при этом есть одна проблема: Если вдруг кнопки или какие-то триггеры будут добавлять без нашего ведома, то событий у них уже не будет, ведь они не будут обрабатываться циклом, в которым мы назначаем обработчик событий на каждую из кнопок. И здесь нам очень пригодится делегирование событий.
// Суть в следующем: Мы берём элемент, который является родителем для всех этих кнопок и работаем с ним. Т.е. мы назначаем обработчик событие на родительский элемент всех кнопок. А внутри этого родительского элемента мы будем проверять на что именно мы кликнули. Мы назначаем функцию для дочерних элементов этого элемента, если они подходят под наши параметры.
// Итак, для примера, получим переменную, которая будет содержать родительский элемент всех наших кнопок.
const buttonsWrapper = document.querySelector('.btn-block');
// У объекта event есть свойство "target", а в нём есть полезное свойство tagName, которое поможет получить название тега, по которому мы кликаем. Используя его мы можем сделать условие, что только при клике на элемент с тегом "BUTTON" мы будем что-то выполнять.
// ? event записываем как evt, чтобы не было ошибок в некоторых случаях, т.к. есть также глобальный объект Event и их можно спутать.
// ? Зачем прописывать "evt.target"? Дело в том, что в HTML-структуре не все элементы поддерживают событие клика. Есть такие теги, которые невозможно кликнуть и у них нет event.target. (например тег <br>) Поэтому, что скрипт правильно работал и не выдавал ошибок, сперва проверяем на существование event.target, далее "и" и в конце проверяем значение свойства tagName, стоит ли там "BUTTON".
/* buttonsWrapper.addEventListener('click', (evt) => {
  if (evt.target && evt.target.tagName == 'BUTTON') {
    console.log('Button clicked!');
  }
}); */
// * Это и есть делегирование событий.
// Кстати, здесь можно было проверить не только tagName, но и nodName или классы.
/* buttonsWrapper.addEventListener('click', (evt) => {
  if (evt.target && evt.target.classList.contains('last')) {
    console.log('Last Button clicked!');
  }
}); */

// * А что будет, если мы добавим тот же обработчик события, но при помощи перебора?
// todo А теперь у нас последняя динамически добавленная в вёрстку кнопка не сработает, потому что не было использовано делегирование!
/* buttons.forEach((button) => {
  button.addEventListener('click', () => {
    console.log('Button clicked!');
  });
}); */

// * И ещё есть один способ, который любят в Google.
// Вместо tagName или className можно проверить на какие-то совпадения. Это делается при помощи метода matches(). Совпадает ли элемент с чем-то? И то, с чем мы будем сравнивать нужно прописать в () как аргумент.
buttonsWrapper.addEventListener('click', (evt) => {
  if (evt.target && evt.target.matches('button.red')) {
    console.log('Red button has been clicked!');
  }
});

// * Добавим для эксперимента ещё кнопку и проверим, что она работает также, как и остальные в вёрстке.
const button = document.createElement('button');

button.classList.add('red');
buttonsWrapper.append(button);
// И да, несмотря на то, что наша новая кнопка была создана уже после создания слушателя событий, она работает также, как и другие!

// * ==> Делегирование событий - это один из наиболее полезных приёмов при работе с DOM-деревом. Он отлично подходит, если есть много элементов с одинаковыми обработчиками, причём при динамическом добавлении новых элементов эти обработчики также будут к ним применяться. Таким образом мы пишем меньше кода и экономим память браузера, ведь обработчик только один.
// |===:===:===:===>
/** links:
 * (Документация по classList): https://developer.mozilla.org/ru/docs/Web/API/Element/classList
 * (Документация по методу matches): https://developer.mozilla.org/ru/docs/Web/API/Element/matches
 * (Статья про делегирование событий №1): https://learn.javascript.ru/event-delegation
 * (Статья про делегирование событий №2): https://medium.com/@stasonmars/%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86-%D0%B2-javascript-d91cbdd8916a
 * */
