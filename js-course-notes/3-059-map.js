'use strict';

// * === Метод map() === * \\

// Ещё одна специфическая структура, которая не всегда встретится, однако знать её необходимо, тем более иногда через неё решать определённые задачи проще.

const user = {
  4: 'Alex',
  surname: 'Smith',
  birthday: '20/04/1993',
  showMyPublicData: function () {
    console.log(`${this.name} ${this.surname}`);
  },
};
// Даже если мы запишем ключи объекта без кавычек, то они всё равно трансформируются в строки. А что, если в ключ передать что-то другое, например число, объект и т.п. ?
// Например ключом первого свойства укажем число "4". Перейдём в консоль и увидим, что она превратилась в строку. Чтобы доказать это обратимся к этому ключу и определим его тип данных через оператор typeof().
console.log(typeof Object.keys(user)[0]); // string
// С объектом же такой финт вовсе не получится и нам выведет синтаксическую ошибку.
console.log(' ');
// * Однако бывают ситуации, когда нам вместо строки требуются другие типы данных в виде ключей.
// Для лучшего понимания смоделируем один из них.
// Представим, что у нас есть список магазинов в торговой сети. Каждый из магазинов содержит перечень товаров и на каждый из них выделяется отдельный бюджет. В коде может быть записано примерно так.
// Каждому магазину-объекту нужно добавить бюджет, чтобы они были попарно. Сразу на ум приходит объект, ведь там у нас как раз пара ключ-значение. Но ведь ключи объектами не могут быть! И здесь нам на помощь придёт Map().
// ? Картами или мэпами называют специфические структуры данных, которые очень похожи на объекты, только у них вместо свойств может использоваться: объект, массив, функция и всё что пожелаем. Также у них есть свои методы для работы с ними. Но тип данных у них остаётся "object".
const shops = [{ rice: 500 }, { oil: 200 }, { bread: 50 }];

// Итак, создаём карту (мэпу). Внутрь скобок мы можем ещё передать начальное значение, но сделаем мы это позже.
// ? Мы укажем базовое значение и именно в таком виде данные существуют внутри карты. Это если копнуть внутрь карты и как она устроена. Это важно знать.
const map = new Map([[{ paper: 400 }, 8000]]);

// * ==| Методы Map() |== *

// map.set(shops[0], 5000); // первым аргументом будет ключ, а вторым значение. Т.е. 1 - наш первый магазин (где у нас было 500 риса) в виде объекта и 2 - его бюджет.
// Далее, чтобы заполнить карту, можно делать это несколькими способами. Можно построчно:
// Также можно и подставить в цикл, где вместо индекса подставить итератор shops[index].
/* map.set(shops[1], 15000);
map.set(shops[2], 25000); */

// А можно сделать цепочкой:
/* map.set(shops[0], 5000)
  .set(shops[1], 15000)
  .set(shops[2], 25000);
*/

// Каждый раз, когда этот метод срабатывает, то возвращается объект map и дальше на нём снова можно применить метод set(). Конечно, если придётся заполнять так десятки или сотни элементов, то это будет очень иррационально и неудобно прописывать каждые данные вручную. В таких случаях обычно либо создают какую-то дополнительную структуру данных, либо получают данные откуда-то из внешней базы данных.
// Допустим у нас есть ещё один массив, где содержатся все бюджеты наших магазинов. Так бывает, когда у нас есть специальные отдельные базы данных, которые менеджеры заполняют из Excel-таблиц. Тогда у нас есть две структуры и нам нужно их соединить. Тут нам поможет обычный цикл или даже лучше метод forEach(), ведь shops это массив.
const budget = [5000, 15000, 25000];
// Так у нас будет взят первый магазин и ему будет назначен первый бюджет, потом второй и т.д.
shops.forEach((shop, index) => {
  map.set(shop, budget[index]);
});

console.log(map);

console.log(' ');

// * Далее при работе с картами мы можем и получать значения из внешних баз данных например, чтобы как-то их обрабатывать. Для этого есть команда - get(). В аргументе дадим ссылку на тот объект, который нужен.
console.log(map.get(shops[1]));

console.log(' ');

// * Также мы можем проверить на наличие чего-то внутри нашей карты. Для этого есть команда - has(). Первым аргументом тот объект, существование которого мы проверяем внутри карты.
console.log(map.has(shops[2]));

// * Кроме этого есть ещё 3 команды:
/* map.delete(key); // удаляет что-то из карты
map.clear(); // полностью очистит карту от содержимого
map.size; // свойство, которое покажет количество элементов внутри карты */

// ? На самом деле карта это массив с массивами, а не объект с объектами, как нам его консоль отображает. (см. стр. 28)
console.log(map);

console.log(' ');

// * ==| Перебор карт |== *
// В наших реалиях иногда так происходит, что карту нужно будет перебрать. Допустим вывести список всех магазинов или их товаров внутри. Или может посчитать бюджет на все магазины. Задач может быть много и очень разных и для перебора у нас есть аж четыре разных способа, их мы и рассмотрим ниже.
// У самой Map() есть целых три встроенных способа для этого.
// map.keys(); - очень напоминает тот метод, что есть у обычного объекта. Возвращает итерируемый объект по ключам.
// Т.к. Map() это итерируемый объект, то мы можем применить на него цикл "for...of" без каких либо манипуляций с Symbol.iterator.
console.log(map.keys());

console.log(' ');

for (const shop of map.keys()) {
  console.log(shop);
}

// * Представим, что у нас стоит задача получить список всех товаров, которые существуют внутри всех магазинов. Самый простой способ реализации будет через map.keys().
// Создадим переменную goods, куда поместим пустой массив, это место, где мы будем складывать наши товары.
const goods = [];
// Чтобы записать в этот массив все товары, конкретно их наименования, напишем:
for (const shop of map.keys()) {
  goods.push(Object.keys(shop)[0]); // push() - для того, чтобы туда отправить какой-то элемент; Т.к. shop это каждый отдельный магазин в виде объекта, то мы не знаем к какому свойству он обратится, какой там ключ будет. Поэтому чаще всего применяется Object.keys()
}
// Объяснение ещё раз кода сверху: Сначала мы карту превратили в массив с объектами "map.keys()". Далее мы обращаемся к каждому отдельному объекту. И чтобы вытащить только его свойства, наименования товаров "paper", "rice" и т.д., мы его также должны преобразовать в массив свойств (по ключам). Нас не интересуют их значения, нас интересуют только строки с наименованиями ключей. И обращаться мы будем к первому элементу массива. (однако такое сработает, только если мы точно уверены, что в массиве есть хотя бы одна запись, иначе нам бы пришлось записать по-другому)
console.log(goods);

console.log(' ');
// * 2-ой способ похож на первый, только перебирать он будет по значениям. *
// Например, если нам нужно найти сумму и среднеарифметическое числе всех бюджетов.
let budgetSum = 0;
let budgetAverage = 0;

for (const price of map.values()) {
  budgetSum += price;
}

budgetAverage = budgetSum / map.size;

console.log(budgetSum);
console.log(budgetAverage);

console.log(' ');

// * 3-ий способ entries(), который также очень похож на метод объекта. *
// Здесь мы уже получим массив с массивами, где было два элемента "свойства" и "значения".

for (const price of map.entries()) {
  console.log(price);
}

console.log(' ');
// Кстати, тут следует показать один популярный приём, т.к. здесь у нас массив, то его обычно деструктуризируют. Т.е. мы разделяем массив на две переменные и теперь можем их выводить или использовать по-отдельности. В принципе два предыдущих способа перебора можно было бы уместить в этом. Можно было бы из каждого магазина вытащить отдельный товар и положить их в переменную goods и тут же посчитать общий бюджет и средне-арифметическое значение всех бюджетов магазинов.
for (const [shop, price] of map.entries()) {
  console.log(shop, price);
}

console.log(' ');

// * 4-ый способ использовать обычный forEach(), который также встроен в них. *
// Параметрами для callback-функции будут значение, ключ и сама карта, на которую можно ссылаться внутри callback-функции. Как и в обычном массиве мы могли бы ссылаться на весь массив.
map.forEach((value, key, map) => {
  console.log(key, value);
});

console.log(' ');

// * ==| Преобразование Map() в объект и наоборот. |== *
// Карты действительно похожи на объекты и данные могут храниться и там и там. И чтобы не терять гибкости, эти структуры мы можем преобразовывать одна в другую.
// Если мы хотим создать карту из объекта, то делаем это командой Object.entries()
const admin = {
  name: 'Al',
  nickname: 'Alienat3d',
  birthday: '01/01/1970',
  showMyPublicData: function () {
    console.log(`${this.name} ${this.surname}`);
  },
};
// * Переводим в формат карты. Начальным значением в скобки мы можем передать в виде массива с массивами. (см. стр. 29) Также и entries() возвращает именно такую структуру данных.
const adminMap = new Map(Object.entries(admin));

console.log(adminMap); // И вот мы уже получили карту из объекта admin. Это пригодится, если мы собираемся расширять эту карту. Например нужно нам добавить какое-то свойство, где его ключ в виде объекта, поэтому мы трансформировали его в Map() и потом уже добавляем такое свойство.
console.log(' ');
// * А иногда требуется обратное. Т.е. из карты трансформировать в объект. Например какая-то функция в коде принимает в себя только объект, она не умеет работать с картами.
const newAdminObject = Object.fromEntries(adminMap);

console.log(newAdminObject);
// |===:===:===:===>
/** links:
 * (Документация): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
 * (Первая половина статьи): https://learn.javascript.ru/call-apply-decorators
 * (Страница учебника про map.set): https://learn.javascript.ru/map-set
 * */
