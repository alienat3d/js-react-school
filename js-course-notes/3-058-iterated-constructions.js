'use strict';

// * === Итерируемые конструкции === * \\

// * ==| for...in |==

// "For ... in" при использовании на объекте, массиве или строке, будет работать с каждой сущностью по порядку, которая является перечисляемой. Т.е. у которой в свойствах стоит "numerable: true".

const user = {
  name: 'Alex',
  surname: 'Smith',
  birthday: '20/04/1993',
  showMyPublicData: function () {
    console.log(`${this.name} ${this.surname}`);
  },
};
// Здесь мы получаем в консоль значение каждого свойства в виде строк, а также метод, который был внутри объекта. Последнее не очень хорошо, ведь чаще задача может быть в том, чтобы выводить данные результата метода.
for (const key in user) {
  console.log(user[key]);
}

console.log(' ');

// Т.к. массивы это частные случаи объекта, то на них мы также можем использовать "for... in".
const array = ['b', 'a', 'c'];

for (const key in array) {
  console.log(array[key]);
}

console.log(' ');

// Также можно перебрать и строку.

const string = 'StrinG';

for (const key in string) {
  console.log(string[key]);
}

console.log(' ');

// ? Однако при переборе массивов и строк с помощью "for... in" есть одна проблема. Может случится, что перебор будет идти не по порядку. В объектах в принципе на порядок всё равно. Поэтому этот момент следует запомнить. "For... in" перебирает не обязательно по порядку. Поэтому не рекомендуется его применять на массивах и строках. /!\

// * ==| for...off |==

// Если всё таки необходимо перебрать подобным образом именно массив или строку, для это специально в ES6 стандарте была введена конструкция "for...of". Она проходит по значениям перебираемого объекта и что-то с ними делает.

// Проведём эксперимент запустим точно такой же как, как сверху, только с конструкцией "for...of".

// Нам следует уже обращаться не к arraySecond[key], а к key, т.к. теперь в key лежат готовые значения перебираемого объекта. Если бы мы также сделали в "for...in", то получили бы лишь ключи или index в массиве и строке.
const arraySecond = ['b', 'a', 'c'];

console.dir(arraySecond);

for (const key of arraySecond) {
  console.log(key);
}

console.log(' ');

const stringSecond = 'StrinG';

for (const key of stringSecond) {
  console.log(key);
}

console.log(' ');

// * === Перебираемые объекты === * \\

// В уроке про символы мы уже узнали, что существуют встроенные технические символы. Это один из тех, что отвечает на вопрос - «Будет ли объект перебираемым?».

// Наглядно можно это увидеть в консоли браузера, если вывести какую-то сущность, как объект.

const berries = [
  'cranberry',
  'blackberry',
  'blueberry',
  'strawberry',
  'raspberry',
];

// И вот, если зайти в Prototypes, то в самом низу мы увидим свойство "Symbol(Symbol.iterator)", что и означает, если он есть, то наш объект перебираемый.
console.dir(berries);

console.log(' ');

// ? К перебираемым объектам относятся: массивы, строки, типизированные массивы, Set(), Map() и DOM-коллекции. (см. ссылки внизу для подробностей)
// Благодаря этому мы получаем два преимущества: 1) строгое соответствие порядка в переборе (как оно было записано в оригинале, так оно и будет выполняться); 2) исключение всех лишних свойств, которые могут быть унаследованы.
// Напишем пример для 2 преимущества, чтобы понять лучше:
Array.prototype.someMethod = function () {};

for (const key in berries) {
  console.log(key);
}

console.log(' ');

for (const key of berries) {
  console.log(key);
}

// ? Кстати, есть полезная команда, которая называется "hasOwnProperty", которая позволит проверить является ли свойство собственным.

// * Итак, суть итерируемых объектов, те которые перебираем с "for...of" или такие структуры, что содержат свойство "Symbol(Symbol.iterator)".
// Но если копнуть глубже, что же представляет из себя этот Symbol.iterator и как его добавить к обычному объекту?
// ? Такое тоже могут спросить на собеседованиях.
// * Дословно «итератор» это метод, который возвращает объект с методом «next». Сейчас мы рассмотрим ниже это на практике. И да, если мы хотим сделать объект перебираемым, то нам необходимо создать итератор вручную.
// В качестве примера создадим объект с зарплатами.
const salaries = {
  john: 500,
  ivan: 1000,
  anna: 5000,
  sayHello: function () {
    console.log('hello');
  },
};

// Теперь напишем функционал для перебора всех зарплат. Чтобы сделать объект salaries перебираемым, т.е. итерируемым, чтобы "for...of" мог работать с ним, нам нужно добавить в объект метод с именем Symbol(Symbol.iterator) - это специальный технический символ, созданный как раз для этого.
// Далее создаём функцию или метод, который и будет отвечать за этот перебор.
// Когда цикл "for...of" запустится на объекте salaries, то он вызовет метод salaries[Symbol.iterator] один раз. И этот метод вернёт нам итератор - это объект с методом "next". И дальше "for...of" будет работать именно с этим объектом, в котором next(), который вернулся из метода Symbol.iterator'а. Если же "for...of" вызовет метод Symbol.iterator, а его не будет, то и появится ошибка, что объект является не итерируемым.
// Итак, если цикл "for...of" получил наш объект с методом next(), и теперь, когда перебор хочет получить следующее значение, он вызывает метод next() объекта Symbol.iterator, а результат этого метода должен иметь определённый вид: это будет объект { done: true, (второго свойства может не быть) value: *значение* }
// ? Здесь мы уже лезем внутрь языка и реализуем то, что было реализовано разработчиками JS до этого.

// * Поставим таки задачу, которую мы хотим реализовать при помощи "for...of" и нашего итератора. Например мы можем сделать так, чтобы каждые 500 единиц зарплаты что-то происходило. Что мы можем для этого сделать?
// Там, где возвращается объект, мы можем сформировать какие-то свойства, которые будут у объекта.
// Текущая или самая минимальная з\п будет у john, а последняя и самая большая з\п у anna. Мы чётко знаем и очертили границы. Ключевое слово "this" ссылается на сам объект, в котором производятся эти действия.
// Итак, мы сделали два свойства, на которые мы можем опираться и метод next(), который будет вызываться, сможет что-то внутри себя с ними сделать.
// Например поставим условие, если текущая з\п меньше последней (максимальной) то увеличиваем на 500.
salaries[Symbol.iterator] = function () {
  return {
    // Обычно именно такой нейминг для свойств и используют, т.к. это очень понятно.
    current: this.john,
    last: this.anna,
    next() {
      if (this.current < this.last) {
        this.current += 500;
        return { done: false, value: this.current }; // именно в таком виде будет возвращаться объект, первое его свойство это done: false, а 2 - новое значение, которое на 500 больше, попадёт в дальнейший перебор.
      } else {
        return { done: true };
      }
    },
  };
};
// Итак, ещё раз, когда запускается цикл "for...of", то запускается также и вся выше описанная комбинация (после первого return) и запускается метод next(). Результатом этого метода всегда будет объект. Причём либо такой объект, который говорит, что наш цикл ещё работает дальше (done: false), либо уже завершился (done: true). Если было false, т.е. цикл ещё работает, то следующим свойство обязательно нужно указать value. Т.е. с каким значением будет работать цикл перебора дальше. Но как только this.current сравняется с this.last, то метод выкинет объект со свойством "done: true" и на этом цикл закончит свою работу.
for (const result of salaries) {
  console.log(result);
}

// ? И такая логика у итераторов всегда, даже у обычных перебираемых объектов, вроде массивов и строк, у них всё тоже самое. Есть возвращаемый объект с методом next(), только его внутренности устроены внутри JS по своему.
// К такому методу, как мы описали выше придётся скорее всего не так уж часто прибегать, ведь есть более простые способы, однако теорию хорошо знать. А также теперь мы узнали как сделать перебираемым любой объект по требованию, если нужно это сделать. И в этом поможет [Symbol.iterator].
// * Также надо знать, что такой итератор можно вызывать и вручную. Т.е. написать вместо "for...of" другую конструкцию:
const iterator = salaries[Symbol.iterator](); // Мы записываем это свойство в отдельную переменную. Но т.к. это метод, то мы его можем сразу же вызвать. И в переменную iterator мы получим объект с методом next() и привязкой к определённому объекту.
// И теперь мы можем вызывать в этом объекте метод next().
console.log(iterator.next());
// ? Этот ручной вид вызова метода next() может понадобится в некоторых ситуациях, например когда мы вызываем такую команду внутри обычного цикла. Ведь там мы можем останавливать циклы при помощи break; или продолжать с continue; и это даёт нам большую гибкость, чем обычный перебор "for...of", который всегда идёт до конца. Но это уже про совсем специфические задачи.
// |===:===:===:===>
/** links: 
 * (for...in versus for...of): https://bitsofco.de/for-in-vs-for-of/
 * (Дока про hasOwnProperty): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty
 * (Заметка «How to iterate over a JavaScript object»): https://stackoverflow.com/questions/14379274/how-to-iterate-over-a-javascript-object
 * («The Essential Guide to JS iterators»): https://www.javascripttutorial.net/es6/javascript-iterator/
 * (Дока про for...of): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...of
 * */
