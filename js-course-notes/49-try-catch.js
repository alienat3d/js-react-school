'use strict';

// * === Ловим ошибки с помощью 'try...catch' === * \\

// * 1.0.0 Когда браузер видит конструкцию "try...catch", то он сперва запустит код, которые нашёл внутри try {}, если всё прошло без ошибок, то часть кода с catch() игнорируется. Но если вдруг в блоке кода try возникнет любая ошибка, то мы переместимся в блок кода catch() {}, который и служит для того, чтобы отлавливать ошибки и что-то с ними делать.
// 1.0.1 А ещё важная особенность такой конструкции, что код, идущий после подобной конструкции продолжит работать даже, если возникла ошибка. Т.е. она предотвращает остановку всего кода, что делает её незаменимой для использования в "опасных" местах, где могут возникнуть ошибки.
// 1.0.2 Кроме того в блок кода catch приходит аргументом объект ошибки, который можно использовать. У него есть три сущности: name (название ошибки), message (сообщение ошибки) и stack (полное сообщение с функциями, которые привели к ошибке).
// 1.0.3 Как и в обработчиках событий в блок catch можем поместить какой-то функционал, срабатывающий при возникновении ошибки, например можем показать какой-то контент, сообщающий, что сервер недоступен или картинку 404 и многое др.
// 1.0.4 Кроме того, есть ещё одна возможность, которой пользуются не так часто - "finally". И работает она также, как и в промисах. Тот код, который находится внутри этого блока выполнится и в случае успеха выполнения блока кода try{} и в случае неудачи.
try {
  console.log('Hello World!');
  console.log(a);
  console.log('More code.');
} catch (error) {
  console.error(error);
  console.error(error.name);
  console.error(error.message);
  console.error(error.stack);
} finally {
  console.log('Will run this always!');
}

console.log('Code still works further.');

// * 1.1.0 Рассмотрим наглядный практический пример применения этой конструкции.
// 1.1.1 Итак на проекте может быть сколь угодно страниц, но например один файл JS-bundle. Но как быть, если в скрипте идёт получение определённых элементов, которые на одних страницах есть, а на других их нет? Тут нам придёт на помощь конструкция "try...catch", мы пробуем в try{} получится ли получить эти элементы, и если нет, то переходим к следующему участку кода, предохраняя весь код от обрывания.
// ? Кстати в блок кода catch(){} можно ничего и не указывать.
try {
  document.querySelector('.cart__btn').addEventListener('click', () => {
    console.log('click');
  });
} catch (error) {
  console.log(error);
}

// |===:===:===:===>
/** links:
 *  https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/try...catch
 * */
