'use strict';

// * === Контекст вызова функции (ключевое слово this) === * \\
// ? Это то, что окружает функцию или в каких условиях она вызывается.
// Рассмотрим примеры из реального мира. Представьте скитающегося человека гражданина мира, что путешествует из страну в страну постоянно, в таком случае можно сказать, что этот человек функционирует в пределах всего мира, ведь у него нет какой-то привязки к определённому месту. Но если он где-то всё же остановится и "пустит корни" и будет там чем-то определённым заниматься, то можно уже говорить о контексте вызова. Теперь у него появилось определённое место для функционирования. С функциями в JS всё точно также.

// * === ПАМЯТКА === \\
// * 1) Обычная функция: this = Window, но если "use strict", то — undefined;
// * 2) Метод объекта: this — сам объект;
// * 3) Конструкторы и классы: this — новый экземпляр объекта;
// * 4) Ручное присвоение: this — call(), apply() и bind().

// 0 Функция может вызываться 4-мя способами и в каждом из них контекст вызова будет отличаться:
// * 1.1.1 Первый метод: Просто вызов функции
// ? Кстати в этом случае "this" будет вести себя по разному, в зависимости установлен режим "use strict" или нет.
// * 1.1.2 Если функция просто запускается и мы используем в ней контекст, то он будет ссылаться на глобальный объект Window.
// todo 1.1.3 Однако если будет прописан "use strict", то мы получим в консоль undefined.
// 1.1.4 Для примера как это работает представим, что у нас есть некая функция sum(), которая возвращает сумму двух аргументов.
// 1.1.5 Используем замыкание функции sum(): хотя переменных a & b у sum() нет, но т.к. у нас есть замыкание, то не найдя эти переменные внутри себя она обращается к родительской функции showThis(), где они уже есть. Соответственно всё таки доступ к a & b sum() имеет.
// ? Кстати, такие задачки не редкость на собеседованиях, т.ч. стоит научиться их правильно решать.
/* function showThis(a, b) {
  console.log(this);

  function sum() {
    console.log(this);
    return a + b;
  }

  console.log(sum());
}

showThis(4, 5); */

// * 2.0 Второй метод: Методы объектов это тоже функции.
// ? 2.1 Если мы используем метод внутри объекта, то контекст вызова будет всегда ссылаться на этот объект.
// 2.2 Но если внутри метода объекта будет создана ещё какая-то функция shout(), которая внутри себя будет обращаться к контексту вызова. Эту же функцию вызываем внутри этого метода. И получим undefined. Потому, что в этом случае это уже простой вызов функции, который не относится к методу объекта, а функция, которая запускается внутри метода объекта. Поэтому контекст был потерян и это уже похоже на первый пункт выше.
/* const obj = {
  a: 20,
  b: 15,
  sum: function () {
    function shout() {
      console.log(this);
    }
    shout();
  },
};

obj.sum(); */

// * 3.0 Третий метод: Функции конструкторы.
// 3.1 Функция конструктор создаст новый объект и в ней у нас свойства, которые обращаются к this, т.к. "name, id, human".
// 3.2 Здесь контекстом вызова для всех методов и свойств будет только что созданный новый объект. В данном случае это "ivan".
// 3.3 Даже если появятся какие-то методы внутри этого прототипа, как в случае с примером "hello", то его "this.name" всё равно ссылается на тот объект, который только что был создан, например "ivan".
// 3.4 Это очень удобно, ведь когда мы создаём всё новые и новые экземпляры, то мы запоминаем каждое свойство конкретного пользователя (например здесь: имя, id).
// 3.5 Тоже самое происходит и в классах.
/* function User(name, id) {
  this.name = name;
  this.id = id;
  this.human = true;
  this.hello = function () {
    console.log('Hello, ' + this.name + '!');
  };
}

const ivan = new User('Ivan', 23);
ivan.hello();
console.log(ivan); */

// * 4.0 Четвёртый метод: ручное присвоение this любой функции.
// 4.1 Стоит задача, чтобы когда запускалась функция sayMyName(), то this имело бы не Window или undefined, а объекта user, чтобы можно было получить доступ к его свойству "name"?
// * 4.2.0 Для этого нам помогут два метода call() & apply().
/* function sayMyName(surname) {
  console.log(this);
  console.log(this.name + ' ' + surname);
}

const user = {
  name: 'John',
}; */
// 4.2.1 Аргументом в метод call() мы как раз передадим контекст вызова, который мы хотим передать в эту функцию, т.е. user.
// sayMyName.call(user, 'Week');
// 4.2.2 Тоже самое делаем и с apply().
// sayMyName.apply(user, ['Week']);
// ? Эти две функции делают одно и тоже, разницы в функционале нет, но есть в синтаксисе. Обратите внимание, что в методе apply() передаём в массиве, в то время как в call() в виде строки.
// * 4.3.1 Есть ещё и третий метод bind(). Он создаёт уже новую функцию, связанную с определённым контекстом.
// 4.3.2 Создадим в качестве примера функцию удваивания. Здесь мы возвращаем this умноженное на num. Здесь нам нехватает какого-то контекста вызова, который бы умножался на это число num, которое будет передано при вызове этой функции.
/* function count(num) {
  return this * num;
} */
// 4.3.3 Создаём новую переменную и в неё поместим новую функцию и передадим туда двойку, ведь нам нужно именно удвоение. Теперь 2 переходит вместо this, а num будет передаваться в функцию double().
// const double = count.bind(2);
// 4.3.4 Теперь в функцию double() мы поместим число, которое нам нужно удвоить.
/* console.log(double(20));
const triple = count.bind(3);
console.log(triple(20)); */

// * 5 Потренируемся:
// 5.1 И мы увидим, что здесь у нас контекстом вызова является сам элемент, на котором произошло событие. Почти всегда this будет равняться "event.target".
// ? Однако тут стоит заметить, что всё же "event.target" используется чаще.
const btn = document.querySelector('button');

/* btn.addEventListener('click', function () {
  console.log(this);
  this.style.backgroundColor = 'yellow';
}); */
// 5.2 Но так работает не всегда. У нас также есть стрелочная функция, которую мы можем использовать в качестве callback-функции. Раньше мы говорили, что у стрелочной функции нет своего контекста вызова, а берёт она его у своего родителя. Теперь у нас возникнет ошибка, поэтому в обработчиках событий использовать стрелочную функцию и this одновременно нельзя и мы заменяем на event.target.
btn.addEventListener('click', (evt) => {
  evt.target.style.backgroundColor = 'yellow';
});
// 5.3 Итак, если бы say() была бы обычной функцией, то this превратился бы в undefined, но т.к. мы используем стрелочную функцию и она берёт контекст вызова у родителя, а родителем является метод sayNumber() объекта obj{}. Следовательно здесь this будет ссылаться на объект obj{}.
// 5.4 Если мы переделаем эту функцию в обычную (со словом function()), то получим соответственно ошибку.
// ? Вообще, если говорить о стрелочных функциях, то они часто используется для модификации чего-то прямо здесь на месте.
const obj = {
  num: 5,
  sayNumber: function () {
    const say = () => {
      console.log(this);
      console.log(this.num);
    };

    say();
  },
};
obj.sayNumber();
// 5.5.1 У стрелочной функции есть свои синтаксические нюансы. Мы можем их существенно сокращать убирая return и {}. И вместо:
/* const double = (a) => {
  return a * 2;
}; */
// 5.5.2 ... напишем:
// ? Однако это работает только с теми стрелочными функциями, чей функционал помещается на одну строчку! На самом деле слово return подставляется автоматически. Также, если у стрелочной только 1 аргумент, то можно не писать круглые скобки.
const double = a => a * 2;
console.log(double(15));

// |===:===:===:===>
/** links:
 *  (Большой гайд по this): https://tproger.ru/translations/javascript-this-keyword/
 * */
