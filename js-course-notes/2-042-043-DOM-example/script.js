'use strict';

const box = document.getElementById('box'),
  buttons = document.getElementsByTagName('button'), // [1]
  circles = document.getElementsByClassName('circle'),
  // Выше всё были довольно старые методы и кроме getElementById() уже почти не используются, но всё же знать их необходимо.
  // hearts = document.querySelectorAll('.wrapper .heart'), // [2]
  wrapper = document.querySelector('.wrapper'),
  hearts = wrapper.querySelectorAll('.heart'), // Мы можем ускорить поиск тем, что укажем искать в уже найденном родителе .wrapper, т.к. .heart лежат внутри него.
  oneHeart = wrapper.querySelector('.heart'); // [3]

// [1.1]: Мы получим все элементы такого типа псевдо-массивом. Вспомним, что псевдо-массив, синтаксически это такой же массив, но без свойственных обычному массиву методов.
// [1.2] Кстати, даже если у нас только один элемент, то мы получим массив с 1 элементом внутри. Чтобы например поменять какой-то стиль у элемента, мы не сможем обратится к массиву, нам нужно выбрать конкретный элемент из массива и уже обращаться к нему, например: buttons[1].
// [2.1]: 1) Преимущество 'querySelectorAll', за что он стал таким популярным, что он получает вложенности. Например есть класс 'wrapper' и внутри него есть класс 'heart' с сердечком.
// [2.2]: 2) Преимущество, что псевдо-массив, полученный через 'querySelectorAll' имеет один метод forEach(). Позволяет перебрать нашу коллекцию по отдельным элементам и с каждым что-то сделать. Например изменить стили, назначить функции и т.д.
// [3] Работает, как и 'querySelectorAll', но только получает не все элементы с данным селектором, а самый первый.
// console.dir(hearts);
// Теперь поменяем текст квадрата на фиолетовый.
box.style.backgroundColor = 'purple';
// А как сразу поменять несколько стилей? Есть специальное свойство cssText
box.style.cssText = 'background-color: #333; width: 415px;';

buttons[2].style.borderRadius = '50%';
// circles.style.backgroundColor = 'red'; выдаст ошибку, т.к. не указан конкретный элемент из псевдо-массива, которому мы меняем цвет фона.
circles[0].style.backgroundColor = 'red';
circles[1].style.backgroundColor = 'yellow';
circles[2].style.backgroundColor = 'green';

// Однако если нам нужно делать одинаковые действия с каждом из элементом, то тут нам пригодится цикл for(). /!\ Впрочем лучше использовать forEach()
// В скобках сперва задаём переменную итератор. Задаём условие для этого цикла. Теперь, мы хотим, чтобы наша переменная отрабатывала до того момента, пока у нас не закончатся элементы в массиве. Для этого пишем 'i < array.length'. Код сам определяет количество элементов в массиве и выполняет это действие столько раз, сколько имеется элементов.
for (let i = 0; i < hearts.length; i++) {
  hearts[i].style.backgroundColor = '#196F3D'; // [4]
}
// [4]: Если мы посмотрим на условие, то изначально i = 0. Если мы подставим 0 в hearts[], то получим первый элемент массива. Потом выполнится какое-то действие, цикл пройдёт и перейдёт к следующему элементу (следующей итерации или повторению действия), так как у нас прописано в условии "i++".

// Теперь вспомним второе преимущество метода 'querySelectorAll', за что разработчики его так любят — метод forEach(). Есть более правильный и приятный способ, вместо того, чтобы писать цикл. Давайте его и применим.
// В скобках пишем callback-function, которая выполнится сразу после выполнения основной функции forEach, ведь forEach метод это тоже функция. Значит сперва выполняется функция forEach, а потом та, что записана у нас внутри.
// В круглых скобках callback function мы передадим три вещи. Сразу следует сказать, что они не все обязательны. Возможно например только первый использовать.
// 1-ый аргумент это каждый элемент, который мы хотим перебрать в нашем цикле forEach. Его можно назвать как угодно, главное чтобы эти названия аргументов не пересекались с названиями переменных, что у нас уже есть. Обычно это что-то вроде "item". Далее через запятую мы можем указать другие аргументы.
// 2-ым всегда идёт "i", то есть итератор (можно задавать как-то по-другому, но общепринято i). Этот аргумент тоже самое, что переменная в цикле for, это порядковый номер элемента.
// 3-им аргументом идёт массив, которым мы передаём в цикл. Однако его нужно назвать иначе, чем тот, который мы используем.
// hearts.forEach(function (item, i, changedHearts) {});

// Итак, если нам нужно только покрасить каждый item, т.е. фон сердечка в оранжевый цвет, то ни порядковый номер, ни массив нам не нужен.
/* hearts.forEach(function (item) {
  item.style.backgroundColor = '#E67E22';
}); */
// Или можно записать даже в очень короткой форме, используя стрелочную функцию:
hearts.forEach((item) => (item.style.backgroundColor = '#E67E22'));
// Сейчас выглядит это примерно одинаково с for(), но когда мы начнём обрабатывать действия пользователя на странице, этот метод будет гораздо удобнее.

//===//

// Очень часто части сайта создаются и генерируются при помощи JavaScript, на таких принципах построены например react, и мы должны уметь создавать новые элементы прямо на лету.
// Для того, чтобы создать элемент используется метод createElement().
const div = document.createElement('div');
// const text = document.createTextNode('Тут был Вася!'); // [5]

// [5]: В некоторых случаях нам надо создавать и текстовые узлы, это такие элементы без оболочек тега. Для этого используют метод глобального объекта document.createTextNode(). Но на практике такое встречается довольно редко.

// Чтобы стилизовать наш <div> раньше существовало свойство className, но теперь не рекомендуется его использовать, так как его заменило свойство classList. В нём мы можем написать разные действия с нашим классом, такие как добавление, удаление, переключение, проверка на содержание или определение применённых классов к элементу. Пример:
div.classList.add('black');

div.innerHTML = '<h1>Hello World!</h1>'; // [7]
// div.textContent = '<h1>Hello World!</h1>'; // [8]

// Но пока наш элемент <div> есть только в JS, в HTML его нигде нету. Воспользуемся нашим деревом DOM и изменим это. Любой элемент можно вставить в конец, вставить после определённого элемента, удалить или заменить, но только по отношению к родителю.
// Мы возьмём наш <div> и добавим его в конец <body>. Воспользуемся методом append (есть более старый appendChild(), но он уже устарел и не используется в современном коде) и в скобках пропишем элемент, который мы хотим вставить в конец <body>.
document.body.append(div);

// Теперь, чтобы поместить наш div внутрь контейнера с сердечками с классом .wrapper, нам нужно ещё получить с помощью querySelector(). Кстати, если мы знаем, что этот класс нужно будет использовать лишь 1 раз, то не обязательно его записывать в какую-то переменную, можно его найти и применить к нему метод в одну строку кода:
// document.querySelector('.wrapper').append(div);
wrapper.append(div);
// * [deprecated] Эти конструкции немного устарели, но их всё равно возможно встретить в старых проектах.
// wrapper.appendChild(div);

// Также есть и обратный метод prepend(), который вставит элемент в начало родителя.
// wrapper.prepend(div);

// Также есть ещё методы before() и after(), чтобы вставлять какой-то элемент перед или после какого-то элемента на странице.

hearts[2].before(div);
// hearts[1].after(div);

// * [deprecated] До этих методов выше, эту функцию выполнял insertBefore(). В первом аргументе указывался элемент, который мы вставляем, а во втором - перед каким элементом нам нужно вставить.
// wrapper.insertBefore(div, hearts[1]);

// Чтобы удалить элемент со страницы можно воспользоваться методом remove().
// circles[0].remove();

// * [deprecated] Раньше также не было удобного метода remove() и его задачи выполнял replaceChild(). Итак чтобы мы делали. Сначала обращаемся к родителю и через метод removeChild() указывали параметром дочерний элемент, который нужно удалить.
// wrapper.removeChild(hearts[2]);

// Чтобы заменить один элемент другим используется метод replaceWith().
// hearts[0].replaceWith(circles[0]);

// * [deprecated] Также был раньше метод, который заменял replaceWith(), это — replaceChild(). Первый аргумент - тот элемент, на который мы хотим что-то поменять, второй - тот элемент, который меняем.
// wrapper.replaceChild(circles[0], hearts[0]);

//* Напоминание: Эти методы должны прописываться всегда по отношению к родительским элементам.

// Как добавлять текст или HTML-код в элементы? Метод "innerHTML" добавляет любой HTML-код на страницу.
// См. выше [7].
// [8]: Но если вдруг этот текст, который хотим вставить на страницу, мы получаем от пользователя, то чтобы обезопасить себя, и пользователь не смог бы вставить вредоносный код, чтобы быть уверенным, что появится только текст, используем другой метод — textContent().

// А как вставить кусочек HTML-кода перед или после HTML-тега? Для этого у нас есть метод insertAdjacentHTML(), сперва прописываем перед точкой тот элемент вёрстки, который будет являться целью этого метода, далее он принимает два аргумента. 1ый - место, куда мы можем вставить этот кусочек HTML кода. 2ой - собственно сам кусочек кода, который вставляем.
div.insertAdjacentHTML('beforebegin', '<h2>Привет мир!</h2>');

// |===:===:===:===>
/** links:
 * (Статья о псевдомассивах): https://habr.com/ru/post/336136/
 * (Страница учебника про CSS-селекторы): https://learn.javascript.ru/css-selectors
 * (Проверка кроссбраузерности фич и технологий): https://caniuse.com/
*/