'use strict';

// * === Опциональная цепочка '?.' (ES11+) === * \\

const box = document.querySelector('.box');
const block = document.querySelector('.block');

// Т.к. в вёрстке такого элемента с классом "block" нет, то результаты будут следующими:
// console.log(block); // null
// console.log(block.textContent); // Uncaught TypeError: can't access property "textContent", block is null
// console.log(1 + 2); // Не выводится вовсе, т.к. предыдущая ошибка заблокировала выполнение кода JS.
// ==v====v==
console.log(block);
// Для того, чтобы избежать ошибки и поломки когда, мы можем создать условие, где скажем, что если "block" существует, то выведем его текстовый контент. Есть и более продвинутый аналог этого "try...catch", его мы рассмотри позже.
/* if (block) {
  console.log(block.textContent);
} */
// Однако эту конструкцию можно сильно упростить при помощи оператора опциональной цепочки "?." Его смысл в том, что он проверяет значение выражения слева от себя и останавливает операцию, если значение undefined или null, при этом без ошибки, которая в ином случае остановила бы выполнение всего кода (как на стр. 10).
console.log(block?.textContent);

console.log(1 + 2); // Сработает, т.к. ошибки не было.

// Однако с этим есть один подводный камень, это работает только на чтении. Если попробовать что-то записать, то будет ошибка.
// block?.textContent = '123';

// |==/—/===/—/==|

// Это что касалось действий с элементами на странице. Но ещё большую пользу этот оператор может принести в работе с данными.
// Часто мы не знаем, что именно содержат эти данные.
const userData = {
  name: 'Al',
  age: null
};
// Представим, что это данные, которые не мы вводили и мы точно не знаем, что в них будет находится.
// console.log(userData.skills.js); // Конечно же тут будет ошибка, ведь свойства объекта с названием "skills" не существует.
// Такое встречается довольно часто на практике, например мы можем работать с разнообразным данными, где в некоторых внезапно может быть нарушена ожидаемая нами структура. В итоге из-за таких вот нетипичных объектов данных наш код может завершаться внезапной ошибкой. Поэтому, чтобы из-за таких данных весь наш код не ломался раньше записывали какие-то длинные условия, например такое:
if (userData && userData.skills && userData.skills.js) {
  console.log(userData.skills.js);
}
// Но это смотрится довольно громоздко и теперь у нас есть специальный оператор, позволяющий значительно сократить подобную длинную цепочку проверок.
// Здесь по-сути оператор опциональной цепочку проверит существование userData.skill и только тогда перейдёт к выводу userData.skills.js в консоль, иначе в консоль выведется "undefined" и код будет выполняться дальше.
console.log(userData.skills?.js);
// Кстати, никто не мешает нам расширить проверку и проверять сперва существует ли userData.
console.log(userData?.skills?.js);
// Однако нужно помнить, чтобы не было ошибки userData должна существовать как переменная.
// ? Оператор хоть и выглядит очень удобным и может захотеться использовать его повсеместно, однако не стоит этим злоупотреблять. Т.к. может произойти ситуация, когда сайт сломается, а мы этого даже не замечаем, т.к. ошибки не выдаётся, что усложняет отладку. Поэтому ставим только там, где реально проблемные места и где он уместен.

// * Также этот оператор можно применять не только со свойствами. Можно его использовать и перед круглыми или квадратными скобками.
const data = {
  name: 'Kate',
  age: undefined,
  say: function () {
    console.log('Hello world!');
  }
};

data.say();
data.hi?.(); // Также удобно использовать, когда к нам приходят какие-то неизвестные кусочки данных со своими методами и с этим оператором мы можем вызывать потенциально несуществующие функции.

// |===:===:===:===>
/** links:
 * (Документация по Optional chaining): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Optional_chaining
*/