'use strict';

// * === Методы перебора массивов === * \\

// * Метод forEach() мы уже должны к этому моменту знать на отлично, однако всё же надо помнить про него одну особенность — этот метод не возвращает новый массив, а перебирает и что-то делает с одним и тем же.
// ? Следующие ниже фильтры, что мы тут разберём, после перебора возвращают уже новый массив.

// * 1.0.0 Метод filter() — фильтрует элементы внутри массива. Разберём на примере.
// 1.0.1 Задача получить все никнеймы наших пользователей из массива userNames чьи имена < 9 символов. Т.е. отфильтровать каждый из них и проверить кол-во символов в каждом из них.
// 1.0.2 Альтернативно здесь могла бы быть задача, например: получить все товары, чья цена меньше, чем 1000 условных единиц. Или получить тех сотрудников, чья зарплата больше, чем ₽100 000.
const userNames = ['james007', 'Super Antagonist', 'Jeeves', 'bambi_33'];
// 1.0.3 Итак, когда мы фильтруем, у нас останется и старый массив и получится новый, уже отфильтрованный по тем условиям, что мы выбрали. Создадим новый массив shortNames, куда будут записываться отфильтрованные из старого массива имена. Здесь у нас name - это каждый отдельный элемент, находящийся внутри массива userNames.
// 1.0.4 Итак нам нужно возвращать из коллбэк-функции элементы, которые подходят под наши условия, именно возвращать, а значит пишем return.
const shortNames = userNames.filter((name) => {
  /*
  Можно было бы воспользоваться классическим условием if...
  if (name.length < 8) {
    return name;
  }
  ... но всё же красивее будет сократить:
  */
  return name.length <= 8;
});

console.log('Метод "filter": ', shortNames);

// * ===:===:===:===*

// * 1.1.0 Метод map() — позволяет взять каждый отдельный элемент массива, изменить его и получить на выходе новый массив.
// 1.1.1 Пример: Допустим у нас есть какие-то ответы на анкету, которые мы получили от пользователя. Но наш пользователь мог случайно нажать shift или caps во время ввода и ввести ответы, где буквы в разном регистре. Наша задача предусмотреть подобные ситуации, если нам нужно получить их в базу данных, допустим, в нижнем регистре.
const answers = ['JiM', '30', 'true', 'BaCKend DEV'];

/* 
Можно было бы написать так...
const result = answers.map(item => {
  return item.toLowerCase();
}); 
... если нам требуется только одна строчка кода, то лучше сократить:
*/
const result = answers.map((item) => item.toLowerCase());

console.log('Метод "map": ', result);
/* 1.1.2 Кстати, нам не обязательно создавать новую переменную, мы могли бы также указать прежде созданный массив answers и перезаписать его новым, с обработанными элементами, но для этого нам уже const не подходит, поэтому заменяем на let.
answers = answers.map(item => item.toLowerCase()); */
// ? Но с точки зрения такого понятия в программировании, как иммутабельность — этого всё же делать не стоит. Т.е. лучше создавать другую переменную для изменённых данных, чтобы исходные данные сохранялись.

// ? Этот метод будет часто использоваться, в том числе в react, чтобы трансформировать какие-то данные, которые приходят, например с сервера.

// * ===:===:===:===*

// ? Методы every() & some() — эти методы очень похожи между собой по своим задачам и структуре.
// * 1.1.0 Метод some() — берёт массив, перебирает его и если у нас хотя бы 1 элемент подходит по условию, которое мы указали, тогда он нам вернёт true, а если нет, то соответственно false.
// 1.1.1 Допустим, что у нас задача проверить, что в массиве есть хотя бы одно число.
const someArray = [4, 'Hello', 'World'];

console.log(
  someArray.some((elem) => {
    return typeof elem === 'number';
  })
);
// * 1.1.2 Метод every() — работает практически также, только он возвращает true, если все элементы отвечают условию, иначе будет false.
const everyArray = ['4', 'Hello', 'World'];

console.log(
  everyArray.every((elem) => {
    return typeof elem === 'string';
  })
);
// 1.1.3 Применений этим двум методам может быть много. Например, если мы пишем какую-то статистическую программу, которая проверяет определённые данные, то метод every() поможет проверить, что если зарплата всех сотрудников больше, чем $1000, то возвращается true и тогда, исходя из этого выполняется дальше какое-то действие в программе. Или если нам нужно проверить, что зарплата хотя бы одного сотрудника больше $10000, то нам поможет метод some().

// * ===:===:===:===*

// * 1.2.0 Метод reduce() — служит для того, чтобы схлопывать или собирать массив в единое целое. Особенно это касается числовых данных и именно на них мы это всё разберём.
// 1.2.1 Допустим у нас есть массив, в котором содержаться числа. У нас стоит задача получить суммы всех элементов массива. Как это сделать?
// 1.2.2 Можно конечно было бы использовать метод forEach(), прибавляя все один за одним к числу в какой-то переменной или даже использовать цикл. Но часто проще будет использовать для таких задач специальный метод reduce().
const numbersArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
// 1.2.3 Здесь нам уже понадобится два аргумента: 1) sum - сумма сложенных до этого элементов, 2) current - текущий итерируемый элемент.
// 1.2.4 Изначально первый аргумент sum у нас равен 0.
// ? 1.2.5 Конечно же тут у нас может быть не только сложение, но и любые другие действия, например вычитание или возведение в степень и т.д.
const additionResult = numbersArray.reduce((sum, current) => {
  return sum + current;
});

console.log(additionResult);
// * 1.2.6 Причём это работает не только с числами, но если даже у нас есть массив со строками, то при помощи reduce() мы можем его собрать воедино.
const stringArray = ['apple', 'pear', 'plum', 'pineapple', 'peach'];
// 1.2.7 Допустим, что нам нужно, чтобы получилась одна большая строка, где были бы указаны все фрукты из массива через запятую. Для реализации у нас есть два варианта:
// 1.2.8 Первый: можем использовать классический способ сложения строк.
/* const stringResult = stringArray.reduce((sum, current) => {
  return sum + ', ' + current;
}); */
// 1.2.9 Второй: можем использовать интерполяцию.
const stringResult = stringArray.reduce((sum, current) => {
  return `${sum}, ${current}`;
});

console.log(stringResult);

// ? 1.2.10 Однако следует также знать, что метод reduce() может принимать ещё один аргумент. Например мы можем поставить запятую после коллбэк-функции и передать какое-то начальное значение, например 100. И тогда у нас вместо sum, которое изначально 0, подставится 100.
const numbersArray2 = [1, 2, 3, 4];

const subtractionResult = numbersArray2.reduce((subt, current) => {
  return subt - current;
}, 100);

console.log(subtractionResult);

// * ===:===:===:===*

// * 1.3.0 Ну, и завершая урок, рассмотрим как можно применить все эти методы на каком-то конкретном кейсе.
// 1.3.1 Допустим, у нас есть какой-то объект, который мы получили с сервера и у нас задача извлечь имена людей, которые прописаны в этом объекте.
const object = {
  john: 'person',
  jennie: 'person',
  cat: 'animal',
  dog: 'animal',
};
// ? 1.3.2 Вспомним ещё один объект для перебора объектов, изученный ранее, entries. Он позволит нам взять какой-то объект и превратить его в матрицу, т.е. массив массивов.
// 1.3.4 Итак, используя "chaining" мы можем далее поставить точку и применить к уже полученному массиву метод массивов filter(). В нём укажем условие, что нам нужно возвращать лишь те item’ы (массивы), где второй элемент соответствует строке 'person'.
// 1.3.5 Следующая задача это получить из отфильтрованных массивов, где вторым элементом является 'person' первые элементы с именами. Для этого используя всё тот же "chaining" добавляем метод map().
const personNames = Object.entries(object)
  .filter((item) => {
    return item[1] === 'person';
  })
  .map((item) => {
    return item[0];
  });

console.log(personNames);
// 1.3.3 Теперь у нас объект преобразовался в массив массивов и мы можем к нему применять методы для работы с массивами. И на него мы можем применить уже такой приём, как "chaining", когда мы выстраиваем операции в последовательную цепочку.
// ? Не рекомендуется сильно приёмом "chaining" увлекаться, но иногда он действительно необходим.

// ? Подытожим: Чем хороши эти методы, которые мы тут разобрали, так это тем, что все они позволяют получить новый массив, при этом соблюдается один из принципов программирования «иммутабельность». А вторая приятная особенность — мы можем запускать все эти методы по цепочке, что мы только что разобрали на примере выше.
// |===:===:===:===>
/** links:
 * https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
 * https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map
 * https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries
 * https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce
 * https://habr.com/ru/companies/developersoft/articles/302118/
 * */
