'use strict';

// * === Дескрипторы свойств === * \\

// ? Эту тему активно спрашивают на собеседованиях, хоть в работе (особенно джунам) она редко нужна. Во всяком случае первая часть урока. Но знать это всё равно необходимо.

// * У каждого из свойств объекта помимо значения есть и 3 специальных атрибута, которые ещё глубже определяют как работает это свойство. Иногда их называют «флагами».

// 1. writable; - если этот флаг в позиции true, то свойство объекта можно изменить
// 2. enumerable; - если этот флаг в позиции true, то свойство будет перечисляться в циклах
// 3. configurable; - если этот флаг в позиции true, то свойство можно будет удалить, а атрибуты его можно изменить

// Обычно эти флаги скрыты в консоли и для всех создаваемых нами свойств они стоят в позиции true.
// Рассмотрим пример их использования
const user = {
  name: 'Alex',
  surname: 'Smith',
  [Symbol('height')]: '180 cm', // и не смотря на то, что флаг у символа enumerable: true, но в переборе мы его не увидим, т.к. это специальный скрытый тип данных.
  birthday: '20/04/1993',
  showMyPublicData: function () {
    console.log(`${this.name} ${this.surname}`);
  },
};
// Выведем в консоль эти флаги специальной командой. Здесь у нас два аргумента: 1) объект на котором мы используем метод глобального объекта Object; 2) свойство, флаги которого нас интересуют.
console.log(Object.getOwnPropertyDescriptor(user, 'birthday'));
console.log(Object.getOwnPropertyDescriptor(user, Symbol('height')));

// Мы также можем изменять эти флаги при помощи другого метода defineProperty(). Этот метод статический и у него есть 3 аргумента: 1) объект, на котором используем метод; 2) свойство, которое интересует; 3) объект с флагами, которые ходим изменить.
Object.defineProperty(user, 'birthday', { writable: false }); // теперь изменить значение свойства "birthday" не получится.
// user.birthday = '30/01/1995'; - выдаёт ошибку "birthday is read-only"

console.log(user);

// |==/—/===/—/==|

// ? Кстати, при помощи defineProperty() мы можем создавать новые свойства, если указать такое, которого нет ещё в объекте. Причём оно будет создано с заданными нами параметрами. И если мы не укажем значения флагов, то они автоматически примут значение false. Это важное отличие от стандартного создания свойства, у которого все свойства по умолчанию true.

// Разберём это на практике. Создадим новое свойство нашему объект, например "gender"
Object.defineProperty(user, 'gender', { value: 'male' });

console.log(Object.getOwnPropertyDescriptor(user, 'gender'));

// Кстати, мы также могли бы добавить свойство динамически, например нам нужно добавить возможность пользователю ввести свой цвет глаз, который будет добавлен в объект с информацией о нём. Также нам необходимо указать в настройках этого свойства, что оно не перезаписываемое. Так как этого свойства у нас ещё не было, то оно создаётся со всеми флагами в значении false, а значит нам нужно ввести true, только для двух других.
// Object.defineProperty(user, 'eyeColor', {
//   value: prompt('Какой у вас цвет глаз?'),
//   enumerable: true,
//   configurable: true,
// });

console.log(Object.getOwnPropertyDescriptor(user, 'eyeColor'));

// |==/—/===/—/==|

// Ещё один пример с использованием совсем другого флага. Допустим вам нужно куда-то выводить данные из этого объекта, но вы хотите получить только действительно данные: имя, фамилию, дату рождения. Но в объекте есть и методы, которые при переборе for...in тоже пойдут в работу. Можем в этом сначала убедиться.

// Но при переборе нам нужно сделать, чтобы не было видно метода. Для этого нам нужно поставить ему enumerable: false.
Object.defineProperty(user, 'showMyPublicData', { enumerable: false });

for (const key in user) console.log(key); // сработало, метод showMyPublicData больше не выводится в консоль перебором.

// |==/—/===/—/==|

// А что если понадобится свойство, которое после создания нельзя не удалить из объекта, не изменить его флаги? Такое действительно бывает и хороший пример такому свойство Math.PI, т.к. число Пи существует только в одном варианте и менять его нельзя.
console.log(Object.getOwnPropertyDescriptor(Math, 'PI'));

// Итак мы можем сделать подобное PI свойство тем, что установим флаг configurable в false. Только с этого момента мы не сможем с помощью defineProperty как-то повлиять на это свойство, либо его флаги, либо удалить или перезаписать.

// |==/—/===/—/==|

// * Для оптимизации изменения флагов у нас также есть метод defineProperties. Он позволяет нам редактировать сразу несколько свойств. Первым аргументом указываем целевой объект, а вторым указываем объект со свойствами, которые нужно изменить.
Object.defineProperties(user, {
  name: { writable: false },
  surname: {
    writable: false,
    configurable: false,
  },
});
// |===:===:===:===>
/** links:
 *  (Документация по методу entries): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries
 *  (Документация по keys): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
 *  (Документация по values): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/values
 * */
