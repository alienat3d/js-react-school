'use strict';

// * === BigInt - Большие числа === * \\

// В работе со сложной логикой, с огромным количеством данных или уникальными длинными ключами может возникнуть ситуация, что достигнем максимально возможного числа, с которым JS умеет правильно работать.
// Это значение записано в спец. свойстве
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991 или 2^(53-1) (два в пятьдесят третьей степени минус один)

// * Если мы хотим использовать числа больше, то следует применять типа данных BigInt, чтобы избежать ошибок при работе с такими большими числами. Чтобы слишком большое число превратить в новый тип данных BigInt нужно всего лишь поставить в конце букву "n".
const bigInt =
  1111111111112222222222222222222223333333333333333333444444444444444444444n;

// * Второй вариант это написать команду, что будет создавать BigInt.
const bigInt2 = BigInt(44444444444444444444555555555555555555555); // эта команда может также принимать в себя строки и конвертировать в большое число.

const bigIntWrong = 1111111111112222222222222222222223333333333333333333444444444444444444444;

const alsoBigInt = 5n;

console.log(typeof(bigInt));

// ? У типа данных bigint есть свои особенности: 
// ? 1) его нельзя использовать с методами встроенного объекта Math;
// ? 2) нельзя смешивать bigint и обычные числа;

// Совершать операции bigint с другим bigint соответственно разрешено.
console.log(1111111111112222222222222222222223333333333333333333444444444444444444444n * 1111111111112222222222222222222223333333333333333333444444444444444444444n);
// Без проблем можно использовать с bigint операторы: -, +, *, **(возведение в степень), %(модуль\деление с остатком). Чуть сложнее будет с / (делением).
console.log(5n / 2n); // получим 2, т.к. операция деления bigint будет всегда возвращать округлённый результат без дробной части.
// ? Ответом операций с bigint будет также bigint.

console.log(bigInt);
console.log(bigInt2);
console.log(bigIntWrong);
console.log(typeof(alsoBigInt));

console.log(typeof(bigIntWrong));

// * ==| Сравнения |==
// Сравнивать bigint с обычным числом можно, но это будет нестрогое сравнение.
console.log(5n < 2);
console.log(5n === 5);

// * И всё же, что если придётся сложить bigint с обычным числом? В этом случае придётся явно конвертировать типы данных.

let bigInt3 = 3n;
let number = 3;

// console.log(bigInt3 + number); // выдаст ошибку
console.log(bigInt3 + BigInt(number));

// * Но иногда бывает и обратная ситуация, когда нужно при сложении получить обычное число.
console.log(Number(bigInt3) + number);
// console.log(+bigInt3 + number); - однако применять для этого унарный плюс нельзя, выдаст ошибку.

// todo ! Важно также помнить, что при конвертации из bigint в обычное число, если оно не влезает в установленный в JS предел, то часть его при конвертации будет просто отброшена!
// ? Потом используем bigint только (!) тогда, когда это действительно нужно! Т.е. когда обычное число выходит за допустимый диапазон.
// |===:===:===:===>
/** links:
 *  (Документация): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/BigInt
 * */
