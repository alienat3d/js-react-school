'use strict';

// * === Инкапсуляция === * \\

// ? Один из основных принципов ООП. Отделение и сокрытие от внешнего мира внутренностей программы, её переменных, функций и прочего называют инкапсуляцией. Ещё говорят, что объект хранит свои данные в приватном порядке. И только методы объекта имеют доступ для его изменения.
// * Зачем это делается?
/*  1) Защита от вмешательства других разработчиков в наш код (что может его сломать).
    2) Возможность без негативных последствий улучшать и дорабатывать код.
    3) Это просто удобно, когда внутренности программы скрыты, а используется лишь её результат. (Сокрытие информации это распространённая особенность, которая часто реализуется в др. ЯП как приватные и защищённые методы и свойства, однако в JS можно лишь имитировать нечто подобное.)
*/
// 1.0.0 Рассмотрим на первом примере с функцией-конструктором, а позже на примере с JS-классом.
/* function User(name, age) {
  this.name = name;
  this.age = age;

  this.say = function () {
    console.log(`Имя пользователя: ${this.name}, а его возраст ${this.age}.`);
  };
} */

/* const al = new User('Al', 36);
console.log(al.name);
console.log(al.age);
al.say(); */
// 1.0.1 Однако также мы можем и задать напрямую значения свойств, например:
/* al.name = 'Jack';
al.age = '50';
al.say(); */
// 1.1.0 Это хороший пример из пункта 1, что любой другой программист, имеющий доступ может случайно изменить наш код и мы уже получим совсем другие значения. Давайте это исправим и с помощью инкапсуляции перепишем код, который был сверху:
// 1.1.1 Заменим this на переменную, которая будет принимать в себя аргумент, который приходит при создании объекта.
// 1.2.0 Теперь внутри объекта создадим два метода, которые позволят работать с переменной userAge снаружи. Первый метод будет по требованию отдавать значение, а второй по требованию будет её изменять. Причём в сеттер можно также вписать разные доп. параметры. Например проверки, что к нам пришло числовое значение и т.п.
// 1.2.1 Также и для записи нового значения создадим метод setAge(). Давайте здесь также напишем проверку, что к нам пришло действительно число, а также, что это значение больше 0, но меньше 110.
function User(name, age) {
  let userName = name,
    userAge = age;

  this.say = function () {
    console.log(`Имя пользователя: ${userName}, а его возраст ${userAge}.`);
  };

  this.getAge = function () {
    return userAge;
  };

  this.setAge = function (age) {
    if (typeof age === 'number' && age > 0 && age < 110) {
      userAge = age;
    } else {
      console.error('Недопустимое значение!');
    }
  };
}

const al = new User('Al', 36);
// 1.1.2 Теперь, с подобным подходом никто не сможет так вот легко напрямую перезаписать свойства. Это происходит потому, что наши переменные инкапсулированы внутри и недоступны снаружи.
// ? 1.1.3 Чтобы теперь мочь работать с такими переменными нам уже нужны геттеры и сеттера (не путать тем понятием, что мы прошли на предыдущем уроке), здесь имеются в виду любые методы, которые позволят получить или записывать новые значения.
al.name = 'Jack';
al.age = '50';
al.say();

console.log(al.userName);

console.log(al.getAge());
al.setAge(50);
al.setAge(500);
console.log(al.getAge());
al.say();

// * |===:===:===:===| * \\

// * 2.0 Рассмотрим пример на JS-классе.
// ? 2.1 Как можно заметить на этом примере, то с классами не так всё просто и в данном примере мы снова получили тот синтаксис, где можно снаружи поменять данные. Чтобы убрать эту проблему нужно использовать несколько иной синтаксис (см. выше.)
// 2.2.0 Обычно на этапе разработки разработчик понимает, что в этом классе какое-то свойство нужно скрыть от внешнего воздействия. Для этого есть спец. синтаксис, это свойства, начинающиеся с "_".
// ? 2.2.1 Стоит оговориться, что это не синтаксис языка, а вне гласная договорённость между разработчиками, что такие свойства и методы не должны быть доступны из-вне и большинство следует ей. В библиотеках или больших скриптах такое будет встречаться повсеместно.
// 2.2.2 Чтобы правильно управлять этим свойством мы будем использовать геттеры и сеттеры, разобранные в предыдущем уроке.
// ? 2.2.4 Однако есть одно новшество в JS, называемое "поля классов", такой синтаксис может даже не сработать в старых браузерах. Он позволяет удобно записывать как свойства, так и методы классов. Его ещё разберём во время обучения библиотеке react. 
// * 2.2.5 Во-первых, он позволяет создавать свойства класса вне конструктора. Например, нам понадобилось свойство surname. Итак это свойство, которое можно записать в объект без конструкции constructor. Это удобно для свойств, которые не будут меняться в зависимости от переданных в класс аргументов.
// * 2.2.6 Также мы можем задавать методы в классе в виде стрелочной функции, чтобы не терять контекст в некоторых случаях.
// ? 2.2.7 Но самое приятное в подобном синтаксисе, что у нас есть возможность создавать приватные свойства в классах. И такой синтаксис создаётся при помощи "#" перед названием свойства.
class Person {
  constructor(name, age) {
    this.name = name;
    this._age = age;
  }

  #surname = 'Maxuell';

  say = () => {
    console.log(`Имя персонажа: ${this.name} ${this.#surname}, а его возраст ${this._age}.`);
  };

  get age () {
    return this._age;
  }

  set age (age) {
    if (typeof age === 'number' && age > 0 && age < 110) {
      this._age = age;
    } else {
      console.error('Недопустимое значение!');
    }
  }
}

const eugene = new Person('Eugene', 18);
// console.log(eugene.age);
// eugene.age = 99;
// console.log(eugene.age);

eugene.say();

// ? 2.2.3 К сожалению, возможность записать значение напрямую, игнорируя геттеры и сеттеры всё ещё осталась. Но хороший программист этого делать не станет. Т.к. "_" в начале имени свойства сигнализирует, что его трогать нельзя. Дело в том, что изначально классов в JS не планировалось, да и появились они ещё сравнительно недавно.
/* eugene._age = 99;
console.log(eugene._age); */

console.log(eugene.surname); // получаем undefined, потому, что свойство стало приватным.

// * 3 Для тренировки запишу-ка собственный класс, пользуясь всем, что узнал на уроке.
class Company {
  constructor (name, niche, totalEmployees) {
    this._name = name;
    this.niche = niche;
    this.totalEmployees = totalEmployees;
  }

  #type = 'ООО';

  say = () => {
    console.log(`Фирма ${this.#type} "${this._name}" работает в сфере ${this.niche} и располагает штатом в ${this.totalEmployees} сотрудников.`);
  };

  get name () {
    return this._name;
  }

  set name (companyName) {
    this._name = companyName;
  }
}

const facebook = new Company('Facebook', 'социальная сеть', 45000);

facebook.say();
facebook.name = 'Twitter';
facebook.say();

// |===:===:===:===>
/** links:
 * http://www.codenet.ru/progr/cpp/ipn.php
 * https://medium.com/devschacht/javascripts-new-private-class-fields-c60daffe361b
 * 
 * */
