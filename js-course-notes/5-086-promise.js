'use strict';

// * === Promise (ES6) === * \\
// * Т.н. "Обещания" — позволяет нам удобно работать с различными асинхронными операциями.
// Асинхронный код у нас бывает, например в таймаутах (когда мы задаём, что какая-то функция должна выполниться только через определённый промежуток времени) или при запросах на сервер (ведь мы точно не знаем когда мы получим ответ от сервера и поэтому операция идёт асинхронно).
// Часто в коде нам требуется сделать какую-то последовательность действий, т.е. если произошло что-то — то выполняем какое-то действие. Можно сказать и "мы обещаем, что если что-то произойдёт, то тогда выполнится определённое действие".
// В работе вы постоянно будем сталкиваться с подобной схемой. Например, когда происходит событие клика, то нам нужно, чтобы только в этом случае произошло определённое действие. Для этого мы постоянно используем callback-функции.
// Однако довольно часто мы можем встретить много действий, которые должны идти одно за другим после выполнения предыдущего.
// Пример: когда мы делаем запрос на сервер, получаем от сервера какие-то данные, например список товаров. После этого мы опять выполняем какие-то действия и снова отправляем их на сервер. После того, как мы второй раз отправили мы снова получаем ответ и что-то делаем с данными. Здесь мы видим чёткую цепочку действий, и каждый следующий этап зависит от результата предыдущего. Вы выполняем следующий этап цепи действий, только если предыдущий этап был успешно выполнен и получен какой-то результат.
// 1.0.0 Для подобной задачи можно было бы написать много функций обратного вызова (callback), но тогда это может превратиться в длинный плохо читабельный код. Иногда подобное называют "callback hell".
// 1.0.1 Рассмотрим на примере: сперва у нас запустится синхронный код console.log(), за ним асинхронный setTimeout(), который выполнится через 2 сек., в котором ещё один таймаут и так у нас уже начинает разрастаться «дерево коллбэков», что не слишком хорошо для читабельности кода, ведь таких коллбэков может быть не один десяток.
// 1.0.2 На примере ниже мы видим, что у нас несколько асинхронных функций, однако коллбэки позволяют соблюдать порядок действий.
/* console.log('Запрос данных...');

setTimeout(() => {
  console.log('Подготовка данных...');

  const product = {
    name: 'TV',
    price: 38995
  };

  setTimeout(() => {
    product.status = 'ordered';
    console.log(product);
  }, 2000);
}, 2000); */
// * 1.1.0 Но чтобы не было "callback hell" и для лучше читабельности лучше использовать promise.
console.log('Запрос данных...');

// 1.1.1 Сначала создаём этот promise. Для этого создаём какую-то переменную и помещаем туда "new Promise()". "Обещание" создано и в неё мы поместим какую-то коллбэк-функцию.
// 1.1.2 Обычно, когда создаётся promise, то внутри коллбэк-функции, которую он принимает помещается два аргумента "resolve" & "reject". По-сути эти аргументы обозначают функции, которые мы сможет туда передавать. И здесь "resolve" - означает "обещание выполнилось", т.е. ожидаемое успешно произошло, а "reject" - "обещание не выполнилось", т.е. что-то пошло не так, как ожидалось.
// 1.1.3 Итак, здесь у нас resolve - является как раз второй таймер, который присваивает продукту статус "ordered" и он должен выполниться, только в случае, если весь предыдущий код успешно выполнился.
// 1.1.5 Но, чтобы у нас данные из product{} попали из одной функции в другую, нам нужно их вытащить. Сделаем это, поместив наш объект product в качестве аргумента в resolve(). И тогда ниже then() будет принимать этот объект аргументом.
const req = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log('Подготовка данных...');

    const product = {
      name: 'TV',
      price: 38995,
    };

    resolve(product);
    reject();
  }, 2000);
});
// 1.1.4 Теперь на promise у нас метод then(), который позволяет выполнять функцию, только когда успешно завершилось ожидаемое, т.е. выполнится функция resolve(). А помещается эта функция в виде коллбэка в then() как аргумент.
// 1.1.6 Здесь у нас уже используется объект product, который мы вернули через resolve() выше, как-то модифицируем в нашей асинхронной функции setTimeout() и выводим в консоль.
// 1.1.7 Допустим, после модифицирование нашего объекта product, точнее присвоения ему статуса "ordered", нам нужно выполнить ещё какие-то действия. Для этого обернём эту конструкцию снова в Promise. Также в resolve передаём модифицированный объект product;
// 1.1.8 Теперь, чтобы использовать второй promise, снова через метод then() в который мы поместим аргумент data, в него придёт наш объект product и в качестве resolve запустится ещё одна функция вывода содержимого data в консоль.
/* req.then((product) => {
  const req2 = new Promise((resolve, reject) => {
    setTimeout(() => {
      product.status = 'ordered';

      resolve(product);
    }, 2000);
  });

  req2.then((data) => {
    console.log(data);
  });
}); */
// ? Важное преимущество такого подхода перед обычным деревом коллбэков, что мы можем возвращать promise из then() по цепочке. Когда одна асинхронная операция выполнится — мы выполним следующую, потом следующую и т.п.
// 1.1.9 До этого мы внутри then() создавали ещё один promise и использовали его как обычные коллбэки. Это поведение можно поменять. Мы из функции then будем возвращать новый promise. Тогда мы просто подставляем цепочкой ещё один .then() следом за предыдущим.
req
  .then((product) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        product.status = 'ordered';

        resolve(product);
        reject();
      }, 2000);
    });
  })
  .then((data) => {
    data.modified = true;
    return data;
  })
  .then((data) => console.log(data))
  .catch(() => {
    console.error('Упс! Кажется что-то пошло не так!');
  })
  .finally(() => {
    console.log('Конец кода.');
  });
// ? Такой подход также называют "Chaining", цепочка асинхронных функций, выполняемых в строгой последовательности (каждая следующая ожидает успешное выполнение предыдущей).
// * 1.2.0 Также следует помнить, что из этих коллбэк-функций мы можем возвращать не только Promise. Пример выше, где мы возвращаем data. Таким образом даже синхронный код мы можем тоже передавать по цепочке с помощью then().
// * 1.3.0 Ну и конечно не забудем про "reject" — это тоже функция, которая выполняется, когда наш promise по каким-то причинам закончился неудачей. Её мы можем получить, например: когда ссылаемся на несуществующий файл; когда сервер не отвечает или возвращает ошибку. Эти случаи мы также обрабатываем при помощи "reject". Чтобы обработать reject есть специальный метод catch() и обычно он ставится после всех then(). И в него также, как и в then() передаём коллбэк-функцию с какой-то логикой, которая сработает в случае ошибки. Таким образом, если произошла ошибка, то все этапы then() пропускаются и JS перейдёт к catch().
// * 1.4.0 Помимо этого у нас ещё есть метод finally(). Это тоже не маловажная часть Promise. Он ставится в самом-самом конце цепочки и используется, когда нам нужно что-то сделать или вывести что-то, независимо от исхода работы Promise.
// ? Ещё один пример практической ситуации, где такое применяется: Допустим мы отправляем данные из нашей формы и делаем это при помощи Promise, создаётся "обещание", что сервер либо примет эти данные, либо не примет. Соответственно можно обработать эти данные при помощи resolve. Если всё пошло по положительному сценарию, то мы выполним какие-то действия - показываем модальное окно на странице, потом его скрываем, обрабатываем данные и т.д. А если что-то пошло не так, то срабатывает catch(), который оповещает пользователя, что что-то пошло не так. И в итоге переходим к finally(), куда мы можем поместить часть кода, который очищает форму. Ведь независимо от того успешно ли ушли данные на сервер или нет, нам требуется очистить форму от данных, что были в ней.
// * 1.5.0 Дополнительные методы Promise: all() & race(). Они тоже будут довольно часто встречаться. Рассмотрим на примере как они работают:
// ? Кстати, иногда, если reject не нужен, хоть это бывает редко, то можно передавать в Promise и один аргумент.
// 1.5.1 Эта функция, которая будет запускаться, принимать в себя аргумент с количеством времени, возвращать Promise, который исполнит функцию resolve через то количество времени, что мы передадим в функцию test.
const test = (time) => {
  return new Promise((resolve) => setTimeout(() => resolve(), time));
};
// 1.5.2 Вызываем функцию, где указываем время 1 с. и в then() мы укажем функцию для resolve() с отображением результата работы в консоли.
// ? Такую функцию можно использовать, например для того, чтобы запускать одинаковые операции через определённый промежуток времени.
/* test(1000).then(() => console.log('1 second'));
test(2000).then(() => console.log('2 seconds')); */
// * 1.5.3 Рассмотрим метод глобального объекта Promise - all(), внутрь себя он принимает массив с промисами. Служит для того, чтобы можно было удостовериться, что все промисы выполнились успешно. Например, когда нам нужно сделать несколько запросов на разные серверы, чтобы получить определённое изображение. Эти серверы соответственно отвечают с разной задержкой. При этом мы хотим, что на сайт нам отобразились все изображения сразу, как только они все загрузятся с серверов.
Promise.all([test(1000), test(5000)]).then(() => { console.log('All successfully done!'); }).catch(() => { console.error('Oops! Something went wrong!'); }).finally(() => { console.log('Thanks for coming!'); }); // выполнен за 5 сек.
// * 1.5.4 Метод race() - переводится как "гонка" и соответствует своему названию по смыслу: он ждёт, когда первый из промисов успешно выполнится и тогда выполняет then().
Promise.race([test(1000), test(5000)]).then(() => { console.log('All successfully done!'); }).catch(() => { console.error('Oops! Something went wrong!'); }).finally(() => { console.log('Thanks for coming!'); }); // выполнен за 1 сек.

// |===:===:===:===>
/** links:
 * (Про Promise 1): https://learn.javascript.ru/promise-basics
 * (Про Promise 2): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise
 * (Наглядныи пример промисов): https://stasonmars.ru/javascript/promisy-v-javascript-dlya-chainikov/
*/
