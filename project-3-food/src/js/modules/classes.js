const classesFunc = () => {
  // 1.0 Прежде, чем создавать наш шаблон рассмотрим нашу вёрстку, что нам необходимо для карточки товара: src для картинки, также alt для неё, название title, текст описания, и цена.
  // 1.1.0 Также запишем и метод конвертации валют, т.к. предполагается, что в будущем в нашей БД цена будет указана в $, а нам нужно в ₽.
  // 1.1.1 Итак, когда наш экземпляр будет создан, то нам из БД будет переданно какое-то число, которое отображает цену в $ и перед тем, как её отрисовать на странице её нужно будет конвертировать в ₽. Для этого нам нужен курс валют exchangeRate. В будущем можно сделать, чтобы он приходил динамически, но пока запишем статическое значение.
  // 1.1.2 Далее вызываем этот метод внутри конструктора, чтобы цена конвертировалась автоматически.
  // 1.2 Создаём в методе render() элемент, в который помещаем вёрстку карточки, дополненную теми данными, что приходят как аргументы и поместить этот элемент на страницу.
  // 1.3.0 Также нам нужно будет помещать элемент куда-то на страницу, а значит нужно получить родителя, например с классом ".container" (или другого). Для этого добавим ещё один аргумент "parentSelector".
  // 1.3.1 Соответственно нужно будет получить элемент со страницы куда будем пушать этот элемент. Мы добавим его в конструкторе, хотя сделать это можно было и в render(), но разницы особой нет. И через метод querySelector() получим его. Теперь у нас будет в свойстве parent лежать конкретный DOM-элемент родителя, в который будет помещаться наш экземпляр-элемент.
  // 1.3.2 С помощью append() помещаем наш новый элемент внутрь родительского.
  // 2.0.1 Также не забываем добавить его в свойства и что с ним нужно будет работать как с массивом.
  class MenuCard {
    constructor(src, alt, title, descr, price, parentSelector, ...classes) {
      this.src = src;
      this.alt = alt;
      this.title = title;
      this.descr = descr;
      this.price = price;
      this.classes = classes;
      this.parent = document.querySelector(parentSelector);
      this.RURexchangeRate = 98;
      this.convertToRUR();
    }

    convertToRUR() {
      this.price = +this.price * this.RURexchangeRate;
    }
    // * [1.2] *
    // * 2.0.0 Поработаем над улучшением динамического создания карточек. Мы могли бы присваивать CSS-класс нашему div’у, чтобы не плодить лишние теги, но также пойти дальше и с помощью rest-оператора позаботиться о возможных дополнительных классах, кастомизирующих наши последующие карточки. Для этого вернёмся к параметрам constructor [Ln 11] и используем rest-оператор.
    render() {
      const element = document.createElement('div');
      // 2.0.2 Теперь, т.к. classes у нас массив, то нужно будет перебрать его как массив, вытащить каждое название CSS-класса и назначить создаваемому div’у.
      // 2.0.3 В итоге просто добавим последним свойством при создании экземпляра карточки необходимые классы. (см. ниже)
      // 2.0.4 Всё вроде бы хорошо, да только если забыть прописать CSS-класс "menu__item", то вёрстка у нас ломается. Можно себя от этого обезопасить условием. И так как если даже CSS-класс, который должен добавляться при создании экземпляра карточки не найден, то rest-оператор всё равно создаст пустой массив. Поэтому надо проверять именно длину массива. И если она будет равна 0, т.е. ни один из классов не передали, то ставим дефолтный класс.
      // 2.0.5 И запишем чуть более грамотно и запишем его в свойства, а то вдруг он нам ещё где-то понадобится. Таким образом ставим дефолтный CSS-класс, который запишем в свойство element и передадим его в качестве добавления класса в метод add().
      // 2.0.6 Но если у нас всё таки есть хотя бы один класс, то добавляем классы из массива созданного rest-оператором.
      if (this.classes.length === 0) {
        this.element = 'menu__item';
        element.classList.add(this.element);
      } else {
        this.classes.forEach((className) => element.classList.add(className));
      }

      element.innerHTML = `
        <img src=${this.src} alt=${this.alt}>
        <h3 class="menu__item-subtitle">${this.title}</h3>
        <div class="menu__item-descr">${this.descr}</div>
        <div class="menu__item-divider"></div>
        <div class="menu__item-price">
          <div class="menu__item-cost">Цена:</div>
          <div class="menu__item-total">
            <span>${this.price}</span> ₽/день
          </div>
        </div>
      `;
      this.parent.append(element);
    }
  }
  // 1.4.0 Итак, теперь, когда шаблон готом, можно приступить к созданию элементов. Можно было бы делать, как в предыдущем уроке по классам:
  /*   const div = new MenuCard();
  div.render(); */
  // 1.4.1 Однако, если мы хотим использовать что-то лишь один раз, то мы могли бы использовать следующий синтаксис. Таким образом он сработает раз и тут же удалится (на него нет ссылок), т.к. мы не присваиваем его никакой переменной.
  // 1.4.2 Далее передаём аргументы, как и прежде в уроке про классы. Т.к. здесь аргументов много, то отформатируем для лучшей читабельности на несколько строк.
  // ? 1.4.3 Здесь особое внимание ссылки на картинки и alt-атрибуты передаём прямо с "", ибо так правильнее.
  new MenuCard(
    'img/tabs/vegy.jpg',
    'vegy',
    'Меню “Фитнес”',
    'Меню “Фитнес” - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',
    7.5,
    '.menu .container',
    'menu__item',
    'test-class' // todo Этот класс можно удалить, создан для примера работы rest-оператора
  ).render();
  // 1.5 Создадим ещё две подобные карточки:
  new MenuCard(
    'img/tabs/elite.jpg',
    'elite',
    'Меню “Премиум”',
    'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',
    15,
    '.menu .container'
  ).render();
  new MenuCard(
    'img/tabs/post.jpg',
    'post',
    'Меню “Постное”',
    'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',
    11,
    '.menu .container'
  ).render();

  // * 3.0 Работаем с NPM-пакетом JSON-server и локальной БД db.json
  // 3.1.0 В then() мы укажем, что мы берём ответ сервера "data" и превратим в обычный объект, с которым можно работать.
  fetch('http://localhost:3000/menu')
    .then(data => data.json())
    .then(result => console.log(result));
  // * 3.2.0 Но зачем же мы тогда устанавливали JSON-server, если мы могли бы просто пользоваться db.json для отображения данных? Дело в том, что тут нам пригодится массив "requests", куда мы будем записывать данные. Для этого нам нужна будет уже поддержка POST-запросов. И чтобы правильно их организовать в JSON-файле нам понадобится пакет JSON-server.
};

export default classesFunc;
