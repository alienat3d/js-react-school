'use strict';

const timerFunc = () => {
  // 1. Создадим переменную для определения какого-то дэдлайна и установим какую-то дату в виде строки.
  // ? Почему в виде строки? Да просто на практике очень часто такой функционал будет прикручен к админке, в которой менеджер или хозяин сайта сможет ввести дату, до которой должен считать наш таймер, а результат ввода будет выводится подобным значением и в виде строки.
  const deadline = '2023-12-31';
  // 2.1 Один из трёх столпов на котором будет держаться наш функционал это функция, которая будет определять разницу между дэдлайном и нашим текущим временем.
  // 2.2 В параметр endTime будет попадать именно значение дэдлайна, но со строкой мы конечно не сможем проводить математические операции, поэтому переведём её в числа. Используем метод Date.parse(), в котором получим количество миллисекунд, а потом вычтем текущее время в миллисекундах, также с методом Date.parse().
  // 2.3.1 Теперь эту разницу в миллисекундах нам требуется превращать в количество дней, часов, минут и секунд.
  // 2.3.2 В случае с днями всё довольно просто, нам нужно количество миллисекунд в дэдлайне разделить на количество миллисекунд в 24 часах, а также нужно будет результат округлить с помощью Math.floor(). Это округление до ближайшего целого значения. Мы берём наш timestamp делим на произведение 1000 миллисекунд 60 и 60 и 24 (так мы получаем количество миллисекунд в сутках).
  // 2.3.3 В случае с часами нам нужно разделить timestamps на количество миллисекунд в одном часе. И вот тут мы можем получить как подходящее количество часов (в пределах одних суток), так и например 100 или 1000 часов, что нам уже никак не подходит, ведь мы также считаем уже отдельно и дни. Поэтому здесь нам также понадобится модуль, оператор %, который делит что-то (в данном случае на 24) и получает остаток от деления.
  // 2.3.4 По принципу вычисления часов также находим и минуты с секундами.
  // 7 На случай, если наша дата "просрочена", т.е. раньше текущего числа, то нам следует выводить нули (или даже скрывать этот блок\выводить сообщение, что акция закончена, в зависимости от ТЗ). Но пока реализуем нули. Итак, ещё на этапе высчитывания разницы миллисекунд и занесения значения в "time", мы можем сделать проверку на отрицательное значение. И если оно будет отрицательным, то мы просто возвращаем нули. Мы даже сэкономим ресурсы пользователю и не будем рассчитывать дальнейшие временные данные, связанные с этим основным числом.
  const getTimeRemaining = (endTime) => {
    let days, hours, minutes, seconds;
    const time = Date.parse(endTime) - Date.parse(new Date());

    if (time <= 0) {
      // Тут мы можем вместо того, чтобы подставлять нули, например вывести какую-то вёрстку или убрать блок.
      days = 0;
      hours = 0;
      minutes = 0;
      seconds = 0;
    } else {
      (days = Math.floor(time / (1000 * 60 * 60 * 24))),
      (hours = Math.floor((time / (1000 * 60 * 60)) % 24)),
      (minutes = Math.floor((time / (1000 * 60)) % 60)),
      (seconds = Math.floor((time / 1000) % 60));
    }

    // 2.4.1 Пока эти переменные существую только внутри этой функции и чтобы их вернуть в удобном виде наружу, чтобы как-то работать с полученными результатами, используем возвращение объекта.
    // 2.4.2 Первым у нас будет возвращаться свойство "total" со значением равным общему количеству оставшихся миллисекунд. Оно нам также понадобится, т.к. нам нужно точно знать, вдруг у нас таймер закончился. Ведь если он закончился, то здесь будет отрицательное значение, т.к. количество миллисекунда в текущей дате будет больше, чем установленной в дэдлайне.
    return {
      total: time,
      days: days,
      hours: hours,
      minutes: minutes,
      seconds: seconds,
    };
  };
  // 6 Чтобы у нас подставлялся 0 к значениям < 10, нам требуется проверить их на значение и подставим 0. И хотя мы тут число превращаем в строку, но в данном случае это роли никакой не играет, т.к. эту строчку мы поместим через textContent на страницу и ошибки не будет. Но теперь значение будет модифицировано, когда нам это необходимо. Для этого создадим небольшую функцию-помощника, которая будет этим заниматься.
  const addZero = (num) => {
    if (num >= 0 && num < 10) {
      return `0${num}`;
    } else {
      return num;
    }
  };

  // 3.1 Создадим функцию, которая будет заполнять вёрстку нашего таймера, основываясь на полученных из getTimeRemaining() данных. В атрибуты нам понадобится родительский элемент (".timer") и собственно дэдлайн, который мы будем в неё передавать.
  // 3.2 Занесём в переменную timer родительский элемент таймера selector, чтобы в будущем можно создавать ещё какие-то таймеры на странице, сделаем эту функцию универсальной.
  const setTimer = (selector, endTime) => {
    const timer = document.querySelector(selector),
      days = timer.querySelector('#days'),
      hours = timer.querySelector('#hours'),
      minutes = timer.querySelector('#minutes'),
      seconds = timer.querySelector('#seconds');
    // 4.1 Третья функция будет обновлять наш таймер каждую секунду.
    // 4.2 Эта функция во-первых будет рассчитывать количество миллисекунд, которое осталось на текущий момент. (time)
    // 4.3 Помещаем данные в вёрстку безопасным способом textContent. Для этого забираем данные из переменной time, в которую был записан результатом действий функции getTimeRemaining() объект с интересующими нас данными времени.
    // 4.4 Ну и запускать эту функцию нам требуется каждую секунду. Для этого нам нужно создать переменную timeInterval и внесём в неё одноимённую конструкцию временного интервала, который будет запускать нужную нам функцию через 1 секунду.
    // 4.5 Но теперь, коли есть интервал, то нужно будет его когда-нибудь остановить. Для этого запишем условие в updateTimer(), что если в объекте time, его свойстве "total" (оставшееся количество миллисекунд до дэдлайна) <= 0, то таймер остановится.
    const updateTimer = () => {
      const time = getTimeRemaining(endTime);

      days.textContent = addZero(time.days);
      hours.textContent = addZero(time.hours);
      minutes.textContent = addZero(time.minutes);
      seconds.textContent = addZero(time.seconds);

      if (time.total <= 0) {
        clearInterval(timeInterval);
      }
    };

    // 5 Чтобы не таймер не перепрыгивал через секунду со значений вбитых по умолчанию в вёрстке, а сразу появлялся с нужными значениями, то следует вызвать функцию ещё до интервала.
    updateTimer();

    const timeInterval = setInterval(updateTimer, 1000);
  };

  getTimeRemaining();
  setTimer('.timer', deadline);
};

export default timerFunc;
