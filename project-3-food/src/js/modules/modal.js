const modalFunc = () => {
  // 1.1 Сперва нам нужно найти в вёрстке триггеры, которые будут вызывать наше модальное окно. Триггеры это такие элементы на странице, которые запускают выполнение какого-то JS кода.
  // 1.2 У них могут быть абсолютно разные классы или даже теги, поэтому частенько, чтобы пометить, что эти элементы у нас вызывают одно и то же действие, им назначаются какие-то определённые data-атрибуты. Например здесь логично будет всем триггером для модального окна дать атрибут "data-modal".
  // 1.3 Похожая система будет также и с обратной ситуацией, когда нам нужно будет закрывать модальное окно. Этому элементу повесим data-close.
  const modalTriggers = document.querySelectorAll('[data-modal]'),
    modal = document.querySelector('.modal'),
    modalCloseButton = modal.querySelector('.modal__close');

  // ? Тут также допустимо использование toggle.
  // 1.5.1 Следуя DRY, мы заметили, что придётся снова повторить кусочек кода для закрытия модального окна, поэтому лучше вынести его в отдельную функцию.
  const closingModal = () => {
    // modal.classList.toggle('show'); // - Вариант с toggle.
    modal.classList.add('hide');
    modal.classList.remove('show');
    document.body.style.overflow = ''; // Не забываем после закрытие модального окна восстанавливать скролл на странице.
  };
  const openingModal = () => {
    modal.classList.add('show');
    modal.classList.remove('hide');
    document.body.style.overflow = 'hidden'; // Чтобы отключать возможность скролла при активном модальном окне.
    // Если модальное окно было открыто пользователем до истечения таймера, то оно больше не открывается по таймеру автоматически, чтобы не раздражать пользователя.
    // FIXME: Вернуть позже.
    // clearInterval(modalTimerID);
  };

  modalTriggers.forEach((trigger) =>
    trigger.addEventListener('click', () => openingModal())
  );
  // 1.5.2 Заметим, что здесь мы сократили запись.
  modalCloseButton.addEventListener('click', () => closingModal());

  // 1.4 Пропишем функционал, чтобы можно было закрывать модальное окно по клику вне самого окна. Внутри проверим, если event.target (куда кликнул пользователь) строго не совпадает с областью модального окна, то мы закрываем окно.
  modal.addEventListener('click', (evt) => {
    if (evt.target === modal) {
      closingModal();
    }
  });
  // ! А вот такой код считается плохой практикой и может не везде работать. К тому же мы нарушаем логику и читабельность кода другими разработчиками:
  /* modal.addEventListener('click', () => {
    if (event.target === modal) {
      modal.classList.add('hide');
      modal.classList.remove('show');
      document.body.style.overflow = '';
    }
  }); */
  // 1.5.1 Также нам нужен функционал, который будет закрывать модальное окно, если на клавиатуре будет нажата клавиша "Escape". Здесь нам понадобится событие keydown.
  // 1.5.2 А также продумает такой момент, чтобы браузер реагировал на клавишу Escape и запускал наш код, только когда модальное окно у нас открыто.
  document.addEventListener('keydown', (evt) => {
    if (evt.code === 'Escape' && modal.classList.contains('show')) {
      closingModal();
    }
  });

  // * 2.1 Представим, что у нас следующая задача - модальное окно должно появляться, когда пользователь долистал страницу до конца или через определённый промежуток времени.
  // 2.2 Это очень частая задача на практике и потому рассмотрим её ниже.
  // 2.3 Поработаем сначала со временем, зададим setTimeout, чтобы модалка вызвалась через, например 10 секунд.
  // FIXME: Вернуть позже.
  // const modalTimerID = setTimeout(openingModal, 10000);

  // 2.4 Далее реализуем функционал, что если пользователь доскроллит страницу до конца, то мы покажем ему модальное окно. Вспомним те метрики, что мы изучили в "4-10-document-and-window", именно они нам сейчас для этой задачи пригодятся.
  // 2.5 Чтобы отследить, что пользователь скроллит страницу мы можем использовать события 'scroll'.
  // 2.6 Здесь можно использовать как вариант ещё одно специальное свойство pageYOffset - оно даёт нам информацию сколько пикселей от верхней кромки страницы пользователь отмотал вниз. Вспомним также уже изученное ранее свойство scrollHeight, которое отдаёт нам полную высоту элемента с учётом прокрутки, которая осталась сверху.
  // 2.7 Чтобы рассчитать момент, когда пользователь доскроллил до конца нам пригодится простая математическая формула: возьмём свойство, отвечающее за прокрутку сверху, возьмём также свойство, отвечающее за высоту клиента, видимой его части и сравним ей с scrollHeight, т.е. с высотой полной прокрутки и видимой высотой контента. Если два этих значения будут совпадать, то значит пользователь долистал до конца.
  // ? В некоторых браузерах может появляться баг, когда даже при полном скролле вниз страницы не появляется модальное окно. Это можно решить отняв 1 пиксель. Тогда модальное окно точно сработает везде.
  // 2.8 Но тот факт, что окно появляется снова и снова, если мы отскроллим вверх и вернёмся тоже не совсем то, что нам нужно. Поэтому доработаем этот скрипт добавив настройки в обработчик событий после запятой, после стрелочной функции.
  // ? Объект со свойством "once: true" означает, что этот обработчик сработает лишь 1 раз до перезагрузки страницы. Однако такой подход у нас не сработает, потому, что мы повесили обработчик на window, а это значит, что события происходит каждый раз, когда мы крутим колёсиком мыши. Поэтому только мы чуточку проскроллим и это событие исчезнет, но знать о нём всё же стоит, даже если здесь оно нам не подойдёт.
  // 2.9.1 Однако мы могли бы удалить обработчик события сразу после того, как он выполнился. Создадим специальную функцию для этого.
  // 2.9.2 Теперь внутри этой функции, после открытия впервые модального окна, удаляем обработчик события. И в скобках removeEventListener указываем чётко, что было назначено до того. Какое событие и какую функцию.
  // 2.9.3 Сейчас, если пользователь доскроллил до конца страницы и увидел один раз модальное окно, сколько бы он не скроллил вверх и вниз, модалка уже не появится.
  const showModalByScroll = () => {
    if (
      window.scrollY + document.documentElement.clientHeight >=
      document.documentElement.scrollHeight - 1
    ) {
      openingModal();
      window.removeEventListener('scroll', showModalByScroll);
    }
  };

  window.addEventListener('scroll', showModalByScroll);
};

export default modalFunc;

// |===:===:===:===>
/** links:
 *  https://www.toptal.com/developers/keycode
 * */
