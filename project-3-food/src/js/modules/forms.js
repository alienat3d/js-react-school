import { openingModal, closingModal } from './modal.js';

const formsFunc = () => {
  // * 1.0 Задача: взять несколько форм, которые есть на сайте и из них отправлять данные в файл server.php. Также мы знаем, что формы 2 и значит функционал будет повторяться.
  // 1.1 Чтобы вручную не создавать два одинаковых обработчика лучше их обернуть в функцию, которую потом просто вызывать при отправки формы.
  // ? Здесь всё ещё будет использоваться немного устаревший XmlHttpRequest, но через несколько уроков будет показан современный вариант.
  // 1.2 Сперва получим все формы.
  const forms = document.querySelectorAll('form');
  // 1.3.0 Опишем функцию для отправки данных. Внутрь передадим атрибут для формы "form" (любой), на который навесим обработчик события, таким образом наша функция станет более универсальной.
  // 1.3.1 Используем событие "submit", которое срабатывает всякий раз, когда мы пытаемся отправить какую-то форму. Либо кликом по кнопке с type="submit", либо клавишей Enter, если она выделена, соответственно.
  // ? Кстати, если кнопка задана тегом <button>, то у неё автоматически стоит type="submit".
  // 1.3.2 Первым делом отменим стандартное поведение браузера.
  // 1.3.3 Создаём XMLHttpRequest. Добавляем настройки через open().
  // 1.3.4 Теперь как нам сделать так, чтобы все данные, которые пользователь ввёл в форме мы бы смогли получить в JS и отправить их на сервер? Самый простой способ подготовить для отправки такие данные из формы — использовать объект, который называется formData. Нам не всегда надо передавать в формате JSON, потому здесь рассмотрим 2 формата: 1) FormData & 2) JSON. Всё зависит от сервера и с чем работает бэкенд.
  // 1.3.5 Создадим собственно FormData и внутрь помести ту форму, из которой нам нужно собрать данные для отсылки на сервер.
  // ? Важно убедиться, что в input'ах всегда указан атрибут "name", иначе FormData не сможет его найти и взять его value, чтобы правильно сформировать объект.
  // 1.3.6 Также не забудем про заголовки. Только в отличии от JSON, Content-type у нас здесь поменялся на 'multipart/form-data'.
  // 1.3.7 С помощью send() отправим данные. Здесь у него уже есть "body" (тело объекта данных для отправки).
  // 1.3.8 Повесим обработчик события "load" (окончание загрузки) на наш запрос, сделаем проверку, что его статус - 200, т.е. "ОК".
  // ? По хорошему мы всегда должны оповещать нашего пользователя прошли ли данные на сервер успешно или они не прошли.
  /* 1.4.0 Создадим специальную переменную "message", куда запишем список тех фраз, которые мы покажем в различных ситуациях: 
        1) loading — когда запрос ещё не ушёл, но не оборвался и нет ошибки; 
        2) success — когда запрос успешно ушёл на сервер;
        3) failure - запрос не прошёл, что-то пошло не так.
  */
  // 1.4.1 Куда же мы будем помещать это сообщение? Частый приём это создание нового блока и туда мы выведем это сообщение. Т.е. динамически создаётся новый блок, который оповестит пользователя. Чаще всего он добавляется к форме. Создадим "div" при помощи createElement().
  // 1.4.2 Сперва мы отправим в "statusMessage.textContent" — "message.loading" и если у пользователя медленный интернет, то он увидит, что началась загрузка.
  // 1.4.3 При помощи append() добавим сообщение в форму.
  // 1.4.4 Также модифицируем textContent нашего statusMessage и в обработчике события "load", т.е. выведем сообщения об успехе, либо ошибке.
  // * 4.0 Чтобы вместо сообщения о загрузки вставить анимированную картинку загрузки просто впишем путь к ней свойству loading.
  // 4.1.0 Теперь нужно найти, где мы его использовали и вместо контейнера 'div' использовать 'img'.
  const message = {
    loading: 'img/form/spinner.svg',
    success: 'Спасибо! Скоро мы с вами свяжемся!',
    failure: 'Упс, кажется что-то пошло не так! Попробуйте снова!',
  };

  const postData = (form) => {
    form.addEventListener('submit', (evt) => {
      evt.preventDefault();
      // 4.1.1
      const statusMessage = document.createElement('img');

      statusMessage.src = message.loading;
      // Хотя разницы особенно нет, но как альтернативу можно использовать:
      // statusMessage.setAttribute('src', message.loading);
      // 4.1.2 Также нашей картинке загрузки понадобятся дополнительные CSS-свойства. Для записи сразу нескольких удобно использовать cssText.
      // ? 4.1.3 Конечно лучше было бы перенести эти стили в CSS-файл и добавлять класс, но для тренировки сделаем сейчас так.
      /*  statusMessage.style.cssText = `
        margin: 0 auto;
        display: block;
      `; */
      statusMessage.classList.add('loading');
      form.insertAdjacentElement('beforeend', statusMessage);

      const request = new XMLHttpRequest();

      request.open('POST', 'server.php');
      // * ====== *
      // ! Когда мы используем связку XMLHttpRequest & FormData, то заголовок устанавливать не нужно. Он установится автоматически. Иначе могут быть ошибки и мы не получим на сервер данные.
      // request.setRequestHeader('Content-type', 'multipart/form-data');
      // * ====== *
      // * 1.6.0 Но что, если мы хотим отправить данные в формате JSON?
      // 1.6.1 Здесь нам уже понадобятся заголовки.
      request.setRequestHeader(
        'Content-type',
        'application/json; charset=utf-8'
      );
      // 1.6.2 Далее нам нужно объект FormData перевести в JSON.
      const formData = new FormData(form);
      // 1.6.3 Но просто так мы его не можем перевести в этот формат и нам нужно воспользоваться следующим распространённым приёмом: Создадим пустой объект.
      const object = {};
      // 1.6.4 Переберём FormData при помощи метода forEach() и помести извлечённые из него данные в object{}.
      formData.forEach(function (value, key) {
        object[key] = value;
      });
      // 1.6.5 Теперь, когда у нас собрался обычный объект, то мы можем осуществить с ним конвертацию в JSON. Для наглядности создадим промежуточную переменную json, хотя можно было бы её сразу в send(body) поместить.
      const json = JSON.stringify(object);

      // request.send(formData);
      request.send(json);
      // ? Есть ещё один нюанс, связанный с бэкенд-разработкой. PHP нативно не умеет с форматом данных JSON и чаще всего такие данные будут отправляться на сервера с использованием NodeJS. Но тем не менее есть возможность поработать и в PHP-окружении с таким типом данных. (см. далее в server.php файле)

      request.addEventListener('load', () => {
        if (request.status === 200) {
          showThanksModal(message.success);
          form.reset(); // не забудем очистить форму, после отсылки данных на сервер
          // ? Альтернативно мы могли бы взять все input'ы в этой форме перебрать их и очистить их value, чтобы они были пустые. Работать будет одинаково.
          statusMessage.remove();
        } else {
          showThanksModal(message.failure);
        }
      });
    });
  };

  // 1.5 Берём массив со всеми формами и методом forEach() переберём их, и каждую обработаем функцией postData().
  forms.forEach((form) => postData(form));

  // * 2.0 Стоит задача красиво информировать пользователя об отсылки его данных в модальном окне. Для этого мы будем скрывать прежнее модальное окно и подставлять вместо него свеже созданное с другим контентом.
  // 2.1 Сперва получим модальное окно в переменную previousModalDialog.
  // 2.2 Скроем при помощи класса "hide предыдущий контент". (Именно скроем, а не удалим, ведь пользователь может снова открыть это модальное окно и тогда там должен быть показан этот контент.)
  // 2.3 Импортированная из modal.js openingModal() откроет наше новое модальное окно.
  // 2.4 Далее нам понадобится обёртка-div thanksModal и ей назначим нужные классы.
  // 2.5 Формируем вёрстку, которая будет в модальном окне с благодарностью пользователю.
  // 2.6 (см. modal.js)
  // 2.7 Теперь нужно отобразить пользователю само сообщение о статусе отправки. Его мы будем передавать как аргумент message. И этот аргумент вставляем в div.modal__title.
  function showThanksModal(message) {
    const originalModalDialog = document.querySelector('.modal__dialog');

    originalModalDialog.classList.add('hide');

    openingModal();

    const thanksModal = document.createElement('div');
    thanksModal.classList.add('modal__dialog');
    thanksModal.innerHTML = `
      <div class="modal__content">
        <div class="modal__close" data-close>×</div>
        <div class="modal__title">${message}</div>
      </div>
    `;
    // 2.8 Не забудем добавить это всё в вёрстку. И т.к. в принципе это модальное окно нам нужно лишь раз, то можно обойтись без промежуточных переменных.
    document.querySelector('.modal').append(thanksModal);
    // * 3.0 Можно пойти ещё дальше и реализовать также функционал, что если пользователь вдруг захочет через какое-то время снова отправить форму, т.е. нам нужно, чтобы через какое-то время всё возвращалось к исходному состоянию. Блок с благодарностью исчезал, а предыдущая вёрстка формы вновь появлялась.
    setTimeout(() => {
      thanksModal.remove();
      closingModal();
      originalModalDialog.classList.add('show');
      originalModalDialog.classList.remove('hide');
    }, 5000);
  }
};

export default formsFunc;
