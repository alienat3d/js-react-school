'use strict'; // Означает, что мы пишем в стандарте ES6 и некоторые "ошибки прошлого" работать не станут.
// Его можно ставить и в отдельные функции.
// Единственное у него могут быть проблемы с =< IE9, но это можно исправить.

a = 5;
console.log(a); // Выдаст ошибку.

// Имя переменной может состоять только из букв, цифр, символов доллара, нижнего подчёркивания и первый символ не должен быть цифрой.
// Названия переменных не должны повторять зарезервированные слова в языке. (error, alert, promt, alert etc.)
console.log(leftBorderWidth);

var leftBorderWidth = 1; // Если var объявлена, то она уже существует в кода, ещё до выполнения скрипта.

console.log(leftBorderWidth);

// console.log(second);

let second = 2; // Создаётся только тогда, когда код до неё доходит. Такое понятие называют hoisting или всплытие перемен. Позволяет нам избежать многих ошибок, а также таким образом мы ускоряем код, т.к. теперь браузер не должен хранить все переменные var, а использует let\const, которые создаются в момент использования. Таким образом код работает быстрее и экономит память браузера.

console.log(second);

// Кроме этого let видна только в блоке кода, ограниченного {}.
{
  let fourth = 4;
}

console.log(fourth);
// console.log(PI);

const PI = 3.14; // Создают константу, которую нельзя поменять.
// Однако обходными путями всё же поменять можно. Например через объект.
const object = {
  name: 'John',
};

object.name = 'Jack';
console.log(object);

/* ТИПЫ ДАННЫХ */

// Числа. Могут быть как целыми, так и дробными. Ещё существую специальные числовые значения: infinity (получается например при делении на 0), либо NaN [not a number], например когда мы проводим операцию, которая не подлежит математической логике, например деления числа на строку.
let number = 7;

console.log(number / 0);
console.log('hello' * 8);

// Строки. Оформляется с помощью "Hello", 'Hallo', `Привет всем`.
let string = 'Hello!';
const string2 = 'Hallo';
const string3 = `Привет, ${username}`;

// Символ. На практике используется довольно редко.
let sym = Symbol();

// Логический. Либо да [true], либо нет [false].
let boolean = true;

// null — это когда чего-то в коде просто не существует. Или ссылка на несуществующую вещь.
null;

console.log(something);

// undefined — это когда какой либо объект уже существует, но значения никакого не имеет.
undefined;

let someVar;

console.log(someVar);

// Объект. Это коллекция данных, структура, которая используется для хранения любых данных. Называется комплексным, т.к. в нём могут содержаться все вышеперечисленные типы данных. В {} содержит данные, которые называются свойством или методом объекта. Методы это функции.
const object = {};

const person = {
  name: 'Al',
  gender: 'male',
  age: 35,
  occupation: 'Freelancer Web-Developer',
  isMarried: true,
};

// Чтобы получить доступ к определённому свойству объекта, например получить профессию человека.
console.log(person.occupation);
// Либо альтернативно таким способом, когда например очень большое название.
console.log(person['gender']);

// Разновидность объектов — массив.
let array = [
  'Alex',
  'Al',
  'Jack',
  'John',
  15,
  true,
  16.1,
  [1, 2, 'apple'],
  { name: 'Jack', age: 27 },
];

console.log(array[0]);

// * 006 * Разница между массивами и объектами в синтаксическом, логическом и функциональном плане *=*

const arr = [1, 2, 3]; // Массив это перечисление сущностей по порядку.

console.log(arr[2]);

const obj = { a: 1, b: 2, c: 3 };

// В объектах идёт пара соотношения "ключ: значение". Тоже писать в массиве будет бардак и усложнение, да и зачем так делать, когда у нас есть возможность записать в объекте?
// Плюс в объекте порядок не имеет особого значения.
// Можно наименования писать в кавычках, явно указывая, что это строки, но ради экономии времени можно этим и пренебречь.
const employees = {
  Anna: 2800,
  Maria: 2500,
  Jack: 3000,
};

// Хоть массивы это частный случай объектов, но у них есть собственные методы и свойства.
// В массивах есть методы по перебору каждого элемента по порядку, также по добавлению нового элемента в конец или начало, свойство длины (сколько элементов сейчас в массиве) и т.п.
// У объектов есть свои, другие методы и свойства и это логично, ведь если в объекте нет чёткой нумерации, то и не нужен метод добавляющий элемент в конец или начало.

// ? Кстати, если возникают какие-то проблемы к обращению сущностей объекта из-за того, что ключ написан цифрой или каким-то непонятным языком, то всегда надёжнее использовать нотацию через []

const names = {
  Алексей: 'это я',
  Катерина: 'это она',
  Александр: 'это он',
  日本語: 'это японский',
  object: {
    item: '1',
    person: 'John',
    arr5: [{}, { name: 'value' }, { something: 'value' }],
  },
};

const dog = 'Джоли';
names[dog] = 'Pluto';
console.log(names[dog]);
console.log(names.日本語);
// Такие конструкции особенно важны, когда мы формируем динамические данные внутри объекта, однако подобное не стоит пытаться делать с массивами, и вот почему:
const fruits = ['apple', 'peach', 'orange'];

fruits[10] = 'cranberry';

console.log(fruits); // образовалось 7 пустых ячеек без каких-либо данных.
