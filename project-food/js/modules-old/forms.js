import { openingModal, closingModal } from './modal.js';
import { postData } from './post-data.js';

const formsFunc = () => {
  // * 1.0 Задача: взять несколько форм, которые есть на сайте и из них отправлять данные в файл server.php. Также мы знаем, что формы 2 и значит функционал будет повторяться.
  // 1.1 Чтобы вручную не создавать два одинаковых обработчика лучше их обернуть в функцию, которую потом просто вызывать при отправки формы.
  // ? Здесь всё ещё будет использоваться немного устаревший XmlHttpRequest, но через несколько уроков будет показан современный вариант.
  // 1.2 Сперва получим все формы.
  const forms = document.querySelectorAll('form');
  // 1.3.0 Опишем функцию для отправки данных. Внутрь передадим атрибут для формы "form" (любой), на который навесим обработчик события, таким образом наша функция станет более универсальной.
  // 1.3.1 Используем событие "submit", которое срабатывает всякий раз, когда мы пытаемся отправить какую-то форму. Либо кликом по кнопке с type="submit", либо клавишей Enter, если она выделена, соответственно.
  // ? Кстати, если кнопка задана тегом <button>, то у неё автоматически стоит type="submit".
  // 1.3.2 Первым делом отменим стандартное поведение браузера.
  // 1.3.3 Создаём XMLHttpRequest. Добавляем настройки через open().
  // 1.3.4 Теперь как нам сделать так, чтобы все данные, которые пользователь ввёл в форме мы бы смогли получить в JS и отправить их на сервер? Самый простой способ подготовить для отправки такие данные из формы — использовать объект, который называется formData. Нам не всегда надо передавать в формате JSON, потому здесь рассмотрим 2 формата: 1) FormData & 2) JSON. Всё зависит от сервера и с чем работает бэкенд.
  // 1.3.5 Создадим собственно FormData и внутрь помести ту форму, из которой нам нужно собрать данные для отсылки на сервер.
  // ? Важно убедиться, что в input'ах всегда указан атрибут "name", иначе FormData не сможет его найти и взять его value, чтобы правильно сформировать объект.
  // 1.3.6 Также не забудем про заголовки. Только в отличии от JSON, Content-type у нас здесь поменялся на 'multipart/form-data'.
  // 1.3.7 С помощью send() отправим данные. Здесь у него уже есть "body" (тело объекта данных для отправки).
  // 1.3.8 Повесим обработчик события "load" (окончание загрузки) на наш запрос, сделаем проверку, что его статус - 200, т.е. "ОК".
  // ? По хорошему мы всегда должны оповещать нашего пользователя прошли ли данные на сервер успешно или они не прошли.
  /* 1.4.0 Создадим специальную переменную "message", куда запишем список тех фраз, которые мы покажем в различных ситуациях: 
        1) loading — когда запрос ещё не ушёл, но не оборвался и нет ошибки; 
        2) success — когда запрос успешно ушёл на сервер;
        3) failure - запрос не прошёл, что-то пошло не так.
  */
  // 1.4.1 Куда же мы будем помещать это сообщение? Частый приём это создание нового блока и туда мы выведем это сообщение. Т.е. динамически создаётся новый блок, который оповестит пользователя. Чаще всего он добавляется к форме. Создадим "div" при помощи createElement().
  // 1.4.2 Сперва мы отправим в "statusMessage.textContent" — "message.loading" и если у пользователя медленный интернет, то он увидит, что началась загрузка.
  // 1.4.3 При помощи append() добавим сообщение в форму.
  // 1.4.4 Также модифицируем textContent нашего statusMessage и в обработчике события "load", т.е. выведем сообщения об успехе, либо ошибке.
  // * 4.0 Чтобы вместо сообщения о загрузки вставить анимированную картинку загрузки просто впишем путь к ней свойству loading.
  // 4.1.0 Теперь нужно найти, где мы его использовали и вместо контейнера 'div' использовать 'img'.
  const message = {
    loading: 'img/form/spinner.svg',
    success: 'Спасибо! Скоро мы с вами свяжемся!',
    failure: 'Упс, кажется что-то пошло не так! Попробуйте снова!',
  };

  const bindPostData = (form) => {
    form.addEventListener('submit', (evt) => {
      evt.preventDefault();
      // 4.1.1
      const statusMessage = document.createElement('img');

      statusMessage.src = message.loading;
      // Хотя разницы особенно нет, но как альтернативу можно использовать:
      // statusMessage.setAttribute('src', message.loading);
      // 4.1.2 Также нашей картинке загрузки понадобятся дополнительные CSS-свойства. Для записи сразу нескольких удобно использовать cssText.
      // ? 4.1.3 Конечно лучше было бы перенести эти стили в CSS-файл и добавлять класс, но для тренировки сделаем сейчас так.
      /*  statusMessage.style.cssText = `
        margin: 0 auto;
        display: block;
      `; */
      statusMessage.classList.add('loading');
      form.insertAdjacentElement('beforeend', statusMessage);

      // * ====== *
      // ! Когда мы используем связку XMLHttpRequest & FormData, то заголовок устанавливать не нужно. Он установится автоматически. Иначе могут быть ошибки и мы не получим на сервер данные.
      // request.setRequestHeader('Content-type', 'multipart/form-data');
      // * ====== *
      // * 1.6.0 Но что, если мы хотим отправить данные в формате JSON?
      // 1.6.1 Здесь нам уже понадобятся заголовки.
      /* request.setRequestHeader(
        'Content-type',
        'application/json; charset=utf-8'
      ); */
      // 1.6.2 Далее нам нужно объект FormData перевести в JSON.
      const formData = new FormData(form);
      // 1.6.3 Но просто так мы его не можем перевести в этот формат и нам нужно воспользоваться следующим распространённым приёмом: Создадим пустой объект.
      const object = {};
      // 1.6.4 Переберём FormData при помощи метода forEach() и помести извлечённые из него данные в object{}.
      formData.forEach(function (value, key) {
        object[key] = value;
      });
      // * *==* *** *==* * //
      // ? 6.0.0 Кстати, есть более элегантный способ преобразить formData в JSON. Для этого используются методы, которые появились сравнительно не так давно.
      // 6.0.1 Сперва, как и прежде указываем метод stringify(), однако дальше с formData всё немного иначе. У него есть специальный метод entries() - он возвращает массив собственных перечисляемых свойств указанного объекта. [Более подробно с примером см. 39-entries.js]
      // 6.1.0 Итак, когда мы обратимся к formData через метод entries(), то мы получим данные в формате матрицы (массив с массивами).
      // 6.1.1 Далее превращаем этот массив обратно в объект. И здесь нам поможет метод fromEntries().
      // 6.1.2 Итак подытожим, что здесь происходит: мы сперва превращаем formData в массив массивов методом entries(), чтобы можно было с ней работать, потом трансформируем обратно в JS-объект методом fromEntries() и в итоге превращаем JS-объект в JSON при помощи stringify().
      const json = JSON.stringify(Object.fromEntries(formData.entries()));
      console.log(json);
      // * *==* *** *==* * //
      // 1.6.5 Теперь, когда у нас собрался обычный объект, то мы можем осуществить с ним конвертацию в JSON.
      // todo 5.0.0 До этого мы привязывали к каждой форме одинаковые действия, но в реальности они могут сильно отличаться. Может поменяться например URL, на который мы ссылаемся. (Например, одна форма ведёт на server.php, другая на какой-нибудь mail.php и т.д.)
      // ? 5.0.1 Также от сервера могут приходить данные в разных форматах и соответственно использоваться разные заголовки и т.д. Поэтому всегда есть смысл выносить функционал общения с сервером в отдельные функции.
      // 
      /*  fetch('server.php', {
        method: 'POST',
        headers: { 'Content-type': 'application/json; charset=utf-8' },
        body: JSON.stringify(object),
      }) */
      // * 5.1 Кстати, т.к. у нас теперь запущен JSON-server, то обращаться мы можем уже не к server.php, а к базе данных JSON и URL, который был создан при помощи этого сервера.
      // 5.3 Теперь все запросы будут записываться в специальном массиве в базе данных (файл db.json), которые мы можем потом как-то дальше использовать.
      postData('http://localhost:3000/requests', JSON.stringify(object))
      
      // 6.2 Дальше мы просто отправляем этот json на сервер.
      // postData('http://localhost:3000/requests', json)
        // .then((data) => data.text()) - 5.2 эту строку теперь можно тоже убрать, ведь нам трансформация данных уже не нужна, ведь она у нас уже есть в функции postData().
        .then((data) => {
          console.log(data);
          form.reset();
          showThanksModal(message.success);
          statusMessage.remove();
        })
        .catch(() => {
          form.reset();
          showThanksModal(message.failure);
        });
      // todo Вообще-то .finally() должно было работать, но с ним почему-то не работает "gulp build"
      /* .finally(() => {
          form.reset();
        }); */
      // ? Есть ещё один нюанс, связанный с бэкенд-разработкой. PHP нативно не умеет с форматом данных JSON и чаще всего такие данные будут отправляться на сервера с использованием NodeJS. Но тем не менее есть возможность поработать и в PHP-окружении с таким типом данных. (см. далее в server.php файле)

      /* request.addEventListener('load', () => {
        if (request.status === 200) {
          showThanksModal(message.success);
          form.reset(); // не забудем очистить форму, после отсылки данных на сервер
          statusMessage.remove();
        } else {
          showThanksModal(message.failure);
        }
      }); */
    });
  };

  // 1.5 Берём массив со всеми формами и методом forEach() переберём их, и каждую обработаем функцией bindPostData().
  forms.forEach((form) => bindPostData(form));

  // * 2.0 Стоит задача красиво информировать пользователя об отсылки его данных в модальном окне. Для этого мы будем скрывать прежнее модальное окно и подставлять вместо него свеже созданное с другим контентом.
  // 2.1 Сперва получим модальное окно в переменную previousModalDialog.
  // 2.2 Скроем при помощи класса "hide предыдущий контент". (Именно скроем, а не удалим, ведь пользователь может снова открыть это модальное окно и тогда там должен быть показан этот контент.)
  // 2.3 Импортированная из modal.js openingModal() откроет наше новое модальное окно.
  // 2.4 Далее нам понадобится обёртка-div thanksModal и ей назначим нужные классы.
  // 2.5 Формируем вёрстку, которая будет в модальном окне с благодарностью пользователю.
  // 2.6 (см. modal.js)
  // 2.7 Теперь нужно отобразить пользователю само сообщение о статусе отправки. Его мы будем передавать как аргумент message. И этот аргумент вставляем в div.modal__title.
  function showThanksModal(message) {
    const originalModalDialog = document.querySelector('.modal__dialog');

    originalModalDialog.classList.add('hide');

    openingModal();

    const thanksModal = document.createElement('div');
    thanksModal.classList.add('modal__dialog');
    thanksModal.innerHTML = `
      <div class="modal__content">
        <div class="modal__close" data-close>×</div>
        <div class="modal__title">${message}</div>
      </div>
    `;
    // 2.8 Не забудем добавить это всё в вёрстку. И т.к. в принципе это модальное окно нам нужно лишь раз, то можно обойтись без промежуточных переменных.
    document.querySelector('.modal').append(thanksModal);
    // * 3.0 Можно пойти ещё дальше и реализовать также функционал, что если пользователь вдруг захочет через какое-то время снова отправить форму, т.е. нам нужно, чтобы через какое-то время всё возвращалось к исходному состоянию. Блок с благодарностью исчезал, а предыдущая вёрстка формы вновь появлялась.
    setTimeout(() => {
      thanksModal.remove();
      closingModal();
      originalModalDialog.classList.add('show');
      originalModalDialog.classList.remove('hide');
    }, 5000);
  }
};

export default formsFunc;
