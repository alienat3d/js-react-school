'use strict';
// todo 5.0.0 До этого мы привязывали [см. forms.js] к каждой форме одинаковые действия, но в реальности они могут сильно отличаться. Может поменяться например URL, на который мы ссылаемся. (Например, одна форма ведёт на server.php, другая на какой-нибудь mail.php и т.д.)
// ? 5.0.1 Также от сервера могут приходить данные в разных форматах и соответственно использоваться разные заголовки и т.д. Поэтому всегда есть смысл выносить функционал общения с сервером в отдельные функции.
// 5.0.2 Для того, чтобы сделать функцию универсальный используем атрибуты url (собственно сам путь к серверу, с которым мы хотим взаимодействовать) и data (тело с данными, которые мы будем отправлять).
// 5.0.3 Мы могли бы позже также внести тип данных в качестве атрибута, но пока оставим его JSON.
// 5.0.4 Теперь, когда мы вернём промис "result", то сразу обработаем его как JSON-формат. Кстати, возвращаем мы промис, чтобы можно было по цепочке then() его дальше обработать, как мы делали раньше.
// ! 5.0.5 Но, важное замечание, здесь можно наделать ошибок, если забыть, что всё это у нас будет асинхронная функция и она не будет ждать остальные части кода. Так как fetch() даёт нам только промис, т.е. буквально "обещание" отдать какие-то данные, когда их получит. Но когда это произойдёт не понятно. Далее создаётся переменная result и туда сперва помещается промис из которого ещё ничего не вернулось и потому ниже при обработки её методом json() может возникнуть ошибка.
// * 5.0.6 Поэтому нам необходимо предусмотреть механизм, который будет нам превращать асинхронный код в синхронный. Ну или хотя бы его подобие, чтобы он сперва дожидался ответа сервера. Причём нужно сделать это в двух местах: там где отправляет и там где получает данные.
// * 5.0.7 "Async \ Await" - именно для подобных задач и был придуман этот оператор "async"\"await".
// 5.0.8 Сперва мы запишем "async" перед какой-то функцией, обозначив, что внутри функции будет асинхронный код.
// 5.0.9 Далее мы ставим его парный оператор "await" и его мы уже ставим перед теми операциями, которые нам необходимо дождаться.
// 5.0.10 Теперь, когда запустится код, оператор "async" сигнализирует JS ориентироваться на парные операторы "await" и ожидать сперва выполнения кода, который последует за ним, прежде, чем переходить к следующим частям кода.
// 5.0.11 И здесь наш асинхронный кусок кода начинает быть похожим на синхронный (хотя на самом деле он не блокирует код дальше, а просто JS будет ожидать окончание запроса (по умолчанию 30 сек.) и потом пропустит работу скрипта дальше).
// 5.0.12 Во втором случае мы также не знаем насколько большой объект нам придёт на обработку JSON в JS-объект и нам нужно также подождать его обработку.
// todo 5.0.13 Теперь, когда функция готова импортируем её в forms.js
// todo 5.0.14 Не забываем прописать атрибуты url & data в скобках и всё, можно удалять старую часть кода (пока закомментируем для наглядности).
export const postData = async (url, data) => {
  const result = await fetch(url, {
    method: 'POST',
    headers: { 'Content-type': 'application/json; charset=utf-8' },
    body: data,
  });

  return await result.json();
};
