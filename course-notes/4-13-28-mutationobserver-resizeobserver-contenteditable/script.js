'use strict';

// * === MutationObserver,ResizeObserver and ContentEditable === * \\
// ? Используется не часто, но знать нужно.
// Пока что мы следили только за событиями, которые происходят на элементах. Они могут быть как спровоцированные пользователем, так и программно. Однако бывает, что перед нами встаёт и противоположный вопрос - Можем ли мы следить за изменениями самих элементов? Например, если что-то происходит с каким-то элементом, то только тогда мы выполняем какое-то действие.
// ? И здесь нам поможет встроенный объект MutationObserver.
// ? При помощи атрибута contenteditable в значении "true" элемент становится доступным для ввода данных пользователем в него. (см index.html) Он может быть полезен особенно, когда мы разрабатываем какие-то административные панели, где клиент может зайти, поменять текст или картинки. И дальше эта информация должна где-то сохраняться и об этом нужно позаботиться, иначе при обновлении страницы вся введённая информация будет попросту исчезать.
// todo Кстати, есть отдельный большой курс по созданию админки с полноценным бэкендом, где данная тема подробно рассматривается. (URL снизу)
const box = document.querySelector('.box');

// 1.1 Получим сущность, которая будет следить за этим элементом. Аргументом передаём некий mutationRecords, который на самом деле список изменений, после которого идёт callback-функция, которая запустится, как только произойдёт какое-то изменение элемента.
const mutationObserver = new MutationObserver((mutationRecords) => {
  // 1.4 Заметим, что в консоль у нас выводится массив, который содержит объект с данными об изменениях. Там мы можем многое использовать, включая даже введённые пользователем данные. (подробнее в ссылке снизу)
  console.log(mutationRecords);
});
// 1.2 Далее мы указываем, что нужно следить за этим определённым элементом и если в нём что-то поменяется, то выполним эту функцию. Для этого есть метод observe() и он принимает два аргумента: 1) тот элемент, за которым мы будем следить; 2) конфигурация с теми настройками, за которыми нужно будет следить внутри этого элемента (ведь обычно нам требуется следить только за чем-то определённым, а не за всеми изменениями и чтобы не перегружать скрипт, здесь можно это настроить). Настройки можно посмотреть на странице MDN, посвящённой MutationObserverInit (ссылка внизу).
// 1.3 Пока из настроек добавим childList, т.е. следить будем за тем, что у нас добавляются или удаляются какие-то узлы (текстовые в том числе).
// observer.observe(box, {
//   childList: true,
// });

// ? 1.4 Итак, для закрепления, алгоритм с MutationObserver довольно прост: 1) Мы выбираем элемент, за которым хотим следить; 2) Выбираем в конфиге за какими именно изменениями нужно следить; 3) В callback-функции указываем скрипт, который должен исполняться при зафиксированных изменениях.
// ? 1.5 Также следует помнить, что observer срабатывает уже после изменений. Т.е. мы не сможем что-то сделать во время действия. Мы работаем уже с результатом изменений. Нельзя например запретить писать определённые буквы в блок. Мы можем только постфактум удалить какие-то символы. Также это всё будет асинхронная операция, а значит отслеживание может выполниться чуть позже или чуть раньше, в зависимости от условий. Поэтому мы получаем массив - набор всех изменений, что произошли.
// ? 1.6 Когда следить за объектом больше не нужно, то можно его удалить.
// observer.disconnect(box);
// 1.7 Здесь такая же логика, как и с памятью, если элемент удаляется из документа, то и observer не оставляет на него ссылки. Эта конструкция будет очищена автоматически, даже если мы не будем вызывать .disconnect()

// ? 2.1 ResizeObserver работает точно по такому же принципу, что и MutationObserver, только отслеживает изменения размеров элементов.
// 2.2 В примере, который был разобран в видео с youtube (ссылка внизу), мы меняем цвет контейнера с зелёного на синий, если его ширина становится меньше 150px.
const resizeObserver = new ResizeObserver((resizeEntries) => {
  const boxElement = resizeEntries[0];
  const isSmall = boxElement.contentRect.width < 150;
  boxElement.target.style.backgroundColor = isSmall ? 'blue' : 'green';
});

resizeObserver.observe(box);
// |===:===:===:===>
/** links:
 * https://www.udemy.com/course/reactjs_admin_panel/?referralCode=DE420C6578305FB12019
 * https://developer.mozilla.org/ru/docs/Web/API/MutationObserver
 * https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord
 * https://www.youtube.com/watch?v=M2c37drnnOA
 * https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver
 * */
