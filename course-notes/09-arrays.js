'use strict';

const array = [1, 2, 3, 4, 5];

// Метод удаления последнего элемента из массива pop()
array.pop();

// Метод добавления элемента в конец массива push()
array.push('7');

// Метод удаления первого элемента из массива shift()
array.shift();

// Метод добавления элемента в начало массива unshift()
array.unshift('1');

console.log(array);
// todo Однако у shift & unshift есть один недостаток, из-за которого их редко используют вот почему:
// Сперва у нас был следующий массив:
const philosophers = [
  'Nietzsche',
  'Sartre',
  'Heidegger',
  'Hegel',
  'Plato',
  'Rand',
  'Marx',
  'Socrates',
];
// Мы добавили в него Фрейда в начало. И теперь у нас поменялись все индексы. Ницше теперь не 0 индекс, а 1, Сартр не 1, а 2 и т.д.
philosophers.unshift('Freud');
// Затем мы вспомнили, что Фрейд это вообще-то психолог, а не философ и удалили его методом shift().
philosophers.shift();
// * И всё бы ничего, но такие изменения индексов занимают ценные ресурсы и время на пересчитывание. И одно дело, когда у нас как здесь всего 8 элементов массива, но их могло бы быть тысяча и тогда это было бы в 100 раз дольше. Поэтому эти методы на реальных проектах редко используют.

// -/==/—/===/—/==/-

// Перебираем элементы массива при помощи цикла for
// * например все URL адреса, которые будут находиться в массиве мы модифицируем, добавляя в конце например "".html"
const links = [
  'tsaplin.dev/index',
  'tsaplin.dev/works',
  'tsaplin.dev/blog',
  'tsaplin.dev/blog-post',
  'tsaplin.dev/contacts',
];

for (let i = 0; i < links.length; i++) {
  links[i] += '.html';
}

console.log(links);

// Помимо обычного цикла есть ещё цикл for of
const redListBirds = [
  'Чибис',
  'Бекас',
  'Обыкновенный зимородок',
  'Озёрная чайка',
  'Обыкновенная кукушка',
  'Седой дятел',
  'Речной сверчок',
  'Пустельга',
  'Сапсан',
  'Коростель',
];
console.log(redListBirds.length);
// Переменная bird будет отображать каждый отдельный элемент внутри массива
for (const bird of redListBirds) {
  console.log(bird);
}
// todo Такая конструкция работает только с массиво-подобными сущностями (массив, псевдо-массив (коллекция), строка, map, set или какие-то определённые элементы со страницы). Но на объекты применить не получится!

// Свойство length в массивах работает немного по-другому. В массивах могут находится элементы с разными порядковыми числами.
// Например действие ниже означает, что мы создаём 99-ый элемент в массиве.
const someArray = [1, 2, 3, 'apple', 5, 6, 7, true, null]

someArray[99] = 'birch'; // todo Грубая ошибка, так как обычно мы не должны строго указывать номер какого-то элемента в массиве. Все элементы должны быть по порядку, хотя бывают случаи, когда это не так. И всё же придерживаемся этого правила.
console.log(someArray.length); // length у нас тут возвращает не количество элементов в массиве, а последний индекс + 1.
console.log(someArray);

// * Ещё один цикл перебора "forEach" *
// В отличие от предыдущих двух, этот метод мы можем чуть более подробно настроить. Потому он довольно популярен среди разработчиков. Т.к. это метод, а метод это функция, то он может принимать в себя ещё и callback-функцию. И эта функция будет выполняться для каждого элемента массива.
const cities = [
  'Moscow',
  'Kyiv',
  'Berlin',
  'Toronto',
  'Amsterdam',
  'Bangkok',
  'Dubai',
];

// Наша функция внутри forEach может принимать 3 аргумента: 1) "item" (или любое другое название) - это каждый элемент, что будет в нашем массиве; 2) "i"(или любое другое название) - номер нашего элемента; 3) "cities" — сам массив.
// Если в работе этой функции нам нужны только элементы, которые мы перебираем, то последние 2 аргумента нам не нужны. Если нужны порядковые номера каждого элемента, то оставляем только 1 и 2 аргументы.
cities.forEach(function (item, i, arr) {
  // Выводим в консоль порядковый номер элемента, конкатенируем с ": " и переменную "item", где находится значение элемента по номером i.
  console.log(i + ': ' + item + ' (массив: ' + arr + ')');
});
// * Очень удобный и потому часто используемый метод, например можно перебрать какой-то контейнер и добавить каждому элементу какой-нибудь класс.

// ? А в чём же тогда преимущество цикла for of? Он нам понадобится, когда потребуется применить break или continue. 

/** Более новый цикл "for-of" */
// Перебирает значения именно в том элементе, что мы берём. Не работает в объектах. Используется только на массивах, в строках и новых видах объектов map, set и т.д.
const nicknames = ['Al', 'Ketio', 'Nox', 'zer0c00l', 'Tr0y'];

// Выводит значения элементов в консоль. А если мы заменим "of" на "in", то выведет порядковые номера элементов.
for (let key of nicknames) {
  console.log(key);
}

for (let key in nicknames) {
  console.log(key);
}

// Существуют ещё несколько методов для трансформации массивов через callback-функцию. Но, честно говоря, используются они намного реже. Это filter(), map(), every(), some(), reduce().
// А вот более реальные, практические методы split(), join(), sort().
// Представьте, что мы получили большую строку.
// *Примеры*

// Переменная "answer" будет получать ответ от пользователя.
// Всё, что введёт пользователь через запятую, станет элементом массива.
let answer = prompt('', ''),
  newArray = [];

// В скобках у метода split() указываем в кавычках какой будет разделитель у указанных элементов, например запятая.
newArray = answer.split(',');
console.log(newArray);

// Но иногда мы хотим сделать наоборот, взять весь массив и отправить одной строкой.
// Это обратный split() метод, который берёт каждый элемент нашего массива и склеивает их в одну строку.
// Внутри скобок join() можно указать разделитель между элементами в нашей строке, например ", ".
let newArray2 = ['Jack', 'Daniels', 'Joe', 'Morgan', 'Bob', 'Marley'],
  i = newArray2.join(', ');

console.log(i);

// А если вдруг нам понадобится отсортировать элементы в массиве по алфавиту, то мы используем метод sort()
let s = newArray2.sort();

console.log(s);
// Изначально sort() сортирует всё по алфавиту и если это только строки, то всё ок, но вот если есть числовые значения, то могут появиться сложности. Просто дело в том, что этот метод сортирует элементы как строки, а не как числовые.
let numbersArray = [1, 2, 15, 25, 333, 9],
  sorting = numbersArray.sort();

console.log(sorting);
// Чтобы метод sort работал правильно с числовыми, нам нужно передать следующую callback function в метод sort(). Дело тут в логике самого JS, а именно "быстрой сортировке", которая сравнивает элементы на положительную или отрицательную разницу.
let numbersArray2 = [1, 2, 15, 25, 333, 9],
  sorting2 = numbersArray2.sort(compareNum);

function compareNum(a, b) {
  return a - b;
}

console.log(sorting2);

/** Ещё есть псевдомассивы — это объект, структура, которая совпадает со структурой массива, он хранит элементы в индексах, но при этом псевдомассивы не обладают методами, свойственными полноценным массивам из-за отличий в своём прототипе. У них нету всех этих методов, что мы выше разобрали. Например можно сформировать псевдомассив с набором элементов с одинаковыми тегами, к примеру.  */
