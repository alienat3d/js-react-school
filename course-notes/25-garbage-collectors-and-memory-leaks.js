'use strict';

// * === Сборщики мусора и утечки памяти (д) === * \\

// ? Эти темы не относятся к базовому JS, но их с удовольствием могут спросить на собеседованиях, ведь эти темы не редко бывают важны на практике.

// * Итак Javascript - это высокоуровневый язык программирования. Почему? Потому, что многие базовые операции за нас уже реализованы на программном уровне. Самый яркий пример - это работа с RAM компьютера. Мы обычно не задумываемся «А куда сохраняется вот этот объект? В какой ячейке памяти компьютера он существует?» И т.п. вещи. Всё это уже реализовано до нас, как и большинство команд, что мы используем в этом языке.
// * Также Javascript - это интерпретируемый язык программирования. Это значит, что программа интерпретатор, построчно запускает код и выполняет его. Отличается от этого компилируемые языки, где программа компилятор сперва переводит всё в двоичный код и только затем исполняется.

// Итак, что касается памяти, то в высокоуровневых языках, таком, как JS, сам интерпретатор решает (условно) автоматически, когда и сколько выделить памяти и как её освободить. Но вот на этапе освобождения памяти могут возникнуть проблемы. Так мы приходим к понятия «сборщиков мусора». Это такие подпрограммы, которые отслеживают выделение и использование памяти компьютера, а при необходимости они могут освобождать эту память, если какой-то код сейчас не используется.
// Вот такая задача, что какая-то часть памяти точно не нужна - она алгоритмически однозначно неразрешима. Поэтому иногда сам разработчик должен решать такие вопросы и помогать интерпретатору, иначе могут быть утечки памяти.

// Алгоритм «mark & sweep»: руководствуется принципом достижимости, специальный скрипт-мусорщик JS идёт от корня по ссылкам ко всем элементам на которые ссылаются родительские элементы (будто вылили огромное ведро с краской) и помечает все, до которых сумел добраться, а которые остались недоступны (не помечены), те удаляются из памяти. Т.е. если хоть где-то в коде есть ссылка на этот элемент или он используется, то он будет оставаться в памяти, а если ссылки нет, то он будет удалён из памяти.

// * ==| Утечки памяти |==
// Проблемы которые могут появиться во время "сборки мусора" называются «утечками памяти».
// ? Часть утечек памяти в современных браузерах уже неактуальны, но знать их всё равно нужно.

// * 1-ый случай утечки памяти скорее всего никогда не встретится на практике. Связан с глобальными переменными, если вдруг в коде не стоит "use strict". В таком случае можно задать переменную без её объявления.
// И если не стоит "use strict", то здесь ошибки не будет. При вызове функции мы создаём новую переменную без её объявления и помещаем туда какое-то значение. Это неправильное поведение.
function func() {
  test = 'string';
  // Тоже самое, что поместить глобальную переменную в объект "window": window.test = 'string'; и такая переменная не может быть удалена сборщиком мусора. Похожая ситуация может произойти и с контекстом вызова. (но об этом позже)
}

// ! Всегда объявляем переменные, когда их создаём, а также не забываем про "use strict".

// * 2-ой случай: забытые таймеры, ведь они хранят ссылки на то, с чем они работают.
/* const someResource = getData(); // например, у нас есть данные, что пришли с сервера.
const node = document.querySelector('.class'); // какой-то элемент со страницы.

setInterval(function () {
  if (node) {
    node.innerHTML = someResource;
  }
}, 1000); */
// Теперь у нас есть ссылка и на переменную node и на получаемые данные, которые могут быть довольно приличного размера. И даже если удалить элемент в переменной node, то ссылка на него всё равно останется, т.к. она существует внутри интервала, что срабатывает каждую секунду, а это уже утечка памяти. Именно поэтому важно останавливать таймеры, после того, как они больше не нужны.

// * 3-ий случай: обработчики событий на несуществующих элементах.
// Мы часто назначаем обработчики событий на разные элементы, но часть этих элементов может исчезнуть в течение работы сайта. Особенно это актуально для веб-приложений, где страница не обновляется в принципе. Может сложиться такая ситуация, когда элемент со страницы может быть удалён, а обработчик события нет. И в нём же остаётся ссылка на элемент, с которым нужно работать. Получается похожая ситуация, как и в случае с setInterval() выше. Раньше это приводило к утечкам памяти в таких старых браузерах, как IE 6-7, но в более новых браузерах, благодаря более современным алгоритмам «сборщиков мусора» это не является больше проблемой. В них обработчики события будут удалятся, если элемент, на который они «слушали» был удалён.
// ? И всё таки, если работаем с нативным JS хорошим тоном будет ручное удаление обработчиков событий через removeEventListener(). А в готовых инструментах, вроде jQuery или React, это уже реализовано за нас.

// * 4-ый случай: замыкание. Теоретически утечка может случится, когда большой объём данных остался в замыкании и не может быть удалён. (несколько примеров в ссылках к этому уроку, но также рассмотрим один показательный ниже)
// Представим, что у нас есть какая-то внешняя функция
function outer() {
  const potentiallyHugeArray = []; // В этой переменной будет содержаться потенциально огромный массив данных

  return function inner() {
    potentiallyHugeArray.push('Hello World!');

    console.log('is working');
  }; // возвращать из внешней будем также внутреннюю функцию
}
// Создадим ещё одну переменную и поместим туда функцию outer(). Теперь вся функция inner() будет содержаться в этой переменной, т.к. она возвращается из outer(). И теперь внутри sayHello через замыкание содержится внутренняя ссылка на массив potentiallyHugeArray и он всё время будет висеть в памяти. Особенно, если мы дальше будем проводить манипуляции с функцией sayHello(). И вроде бы outer() уже отработала, но благодаря тому, что в ней возвращается другая функция замыкание сохраняется и в ней сохраняется ссылка на тяжёлый массив.
// ? Поэтому с замыканиями нужно быть аккуратными, чтобы не получить утечку памяти.
const sayHello = outer();
// |===:===:===:===>
/** links:
 *  https://learn.javascript.ru/garbage-collection
 *  https://html-plus.in.ua/kak-izbezhat-utechek-pamyati-v-javascript/
 *  https://developer.chrome.com/docs/devtools/memory-inspector/
 *  https://nuancesprog.ru/p/12524/
 * */
