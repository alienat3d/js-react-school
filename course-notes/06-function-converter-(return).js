'use strict';

const USD = 85.38;
const EUR = 93.49;
const UAH = 2.31;

const BANK_COSTS = 0.15;
// Здесь важная деталь: Мы делаем наши функции универсальными, не привязывая их к какой-то конкретной переменной.
// ? Кстати здесь мы используем подход DRY (Don’t Repeat Yourself)
function convertToRUR(amount, currency) {
  const result = Math.round(amount * currency);
  console.log('В пересчёте на рубли: ' + result);
  return result;
}

function convertFromRUR(amount, currency) {
  const result = Math.round(amount / currency);
  console.log('В пересчёте с рублей: ' + result);
  return result;
}

// * Для того, чтобы рассмотреть пример для чего нужен оператор возврата return, представим, что полученное число нужно также сложить с ценой, которую берёт банк за перевод. Для того, чтобы реализовать такой функционал нам необходимо сперва вернуть результат из функции оператором возврата return.
// ? Возвращать можно абсолютно любое значение или сущность, а не только результаты вычислений.
function totalSum(result) {
  const total = Math.round(result + result * BANK_COSTS);
  console.log('Общая сумма вместе с банковской комиссией: ' + total);
}
// Внутрь функции totalSum передаём результат вычислений функции convertToRUR. То есть там появится какое-то число, которое мы возвращаем оператором return в самой функции. Это число передастся в качестве аргумента result в функцию totalSum и она уже будет работать с этим числом.
// totalSum(convertToRUR(100, UAH));
// Тоже самое может быть удобнее записать через промежуточную передачу результата в переменную.
const res = convertToRUR(100, UAH);
totalSum(res);

// ? Также желательно, чтобы одна функция выполняла одно действие, не смешивая всё подряд.

convertToRUR(7000, USD);
// convertToRUR(100, EUR);
// convertToRUR(25000, UAH);

// convertFromRUR(50000, USD);
// convertFromRUR(9000, EUR);
// convertFromRUR(50000, UAH);

// * Ещё один пример, применения return: В основе приёма компонента высшего порядка лежит, что функция возвращает другую функцию.
// В результате работы функции func1 возвращается функция func2, которую мы можем также, как и результат записать в переменную и дальше где-то использовать.
function func1() {
  return function func2() {
    // # Code...
  };
}

// * Также return можно использовать и вовсе без значений.
function test() {
  for (let i = 0; i < 5; i++) {
    console.log(i);

    if (i === 3) return; // Например можно в условии записать, что по достижении итератора i до 3, то функция целиком завершится. Кстати в такой короткой записи не обязательно указывать {}, как мы видим. Такой приём полезен, когда нам нужно закончить полностью функцию без каких-то лишних движений.
  }
  console.log('Done'); // Не покажется, т.к. функция прекратила свою работу после слова return
}
test();

// ? Кстати вернёт такая функция undefined. Кстати любая функция на уровне движка JS как бы дописывает у себя в конце return undefined. Потестим?
function doNothing() {}
console.log(doNothing() === undefined);

// ? Остерегайтесь переноса строки после return, иначе JS подставит после этого слова ; и весь код ниже будет недоступным.