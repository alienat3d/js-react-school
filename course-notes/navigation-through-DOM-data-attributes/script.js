'use strict';

// * ===/ Путешествуем по DOM-дереву /===
// Представим, что есть задача взять какой-то элемент и обратиться к его родителю или к следующему элементу и у них уже поменять класс. Это очень частые задачи и работать с этим нужно уметь.
// Начнём с самых главных элементов DOM-дерева. Мы уже видели, что можно получить тег body, по команде document.body, тоже самое можно сделать и с head. Последнее полезно например, если мы динамически подставляем стили или что-то подобное.
// console.log(document.body);

// console.log(document.head);
// ? В head мы могли бы зааппендить какой-то мета-тег или css-link, который будет подставлять css-стили или шрифты и т.д.

// Если же мы поднимемся на уровень выше, то уткнёмся в тег <html>. В JS ему соответствует свойство, которое document.documentElement
// console.log(document.documentElement);

// Вспомним базу, родительский элемент - это тот, что объединяет другие, дочерние элементы и стоит на уровень выше в DOM-дереве. Их мы тоже можем получить при помощи трёх команд.
// ? Самая полезная в практической деятельности это метод childNodes().
// console.log(document.body.childNodes);
// Теперь мы получили в консоль дочерние узлы body, которые в нём содержаться.
// Также мы увидим дополнительные узлы, которые генерятся динамически live server’ом, если мы его использовали.
// Даже пустая строчка с переносом строки считается за текстовый узел\ноду.
// Так каждая сущность в DOM-дереве является узлом, но не каждый узел является элементом. Всё что мы видим в тегах - это элементы, но многое, что и не видим, вроде переноса строк - является узлом. Или например <li></li> это DOM-элемент, а внутри него текст, это текстовый DOM-узел.

// ? Также у нас есть два метода, которые позволяют получить либо первый дочерний элемент родительского элемента, либо последний.
// console.log(document.body.firstChild);
// console.log(document.body.lastChild);

// ---- ==//== ---- ==//== ---- ==//== ----

// * Итак, до этого мы всегда отталкивались от родителя, а теперь наступило время оттолкнуться от абсолютно любого элемента на странице. Поработаем с командами, которые позволяют получить "родителя", "соседей" и "детей".
// Напомним, что если мы собираемся использовать элемент лишь раз, то нам даже не нужно помещать его в какую-то переменную.
// Допустим, что у нас стоит задача, по клику на кнопку получить её родителя. Для этого мы можем использовать команду "parentNode", которая и вернёт нам родителя.
// console.log(document.querySelector('#current').parentNode);
// А что если мы хотим получить родителя родителя какого-то элемента? Мы можем продублировать эту команда два раза.
// console.log(document.querySelector('#current').parentNode.parentNode);

// ---- ==//== ---- ==//== ---- ==//== ----

// ? В HTML 5 появились data-атрибуты, которые прекрасно помогают нам легко получать доступ именно к тем элементам, которые нам нужны в вёрстке.
// Конечно мы могли бы как и раньше везде расставить ID, но у этого свойства есть один минус, о которым будет чуть ниже. К тому же этот подход не такой универсальный как дата-атрибуты. Ведь иногда нам нужно назначить что-то очень свойственное, на что можно будет потом легко ориентироваться. Именно для этого были созданы data-атрибуты.
// ? Начинаются они всегда "с data-...", причём там где ... мы выбираем сами что написать. Часто там указывают "data-current", "data-modal" или "data-close". Причём дата-атрибут может быть как уже со значением, так и без него, что будет приравнено просто к "=true".
/* 
  <li data-current="3">3</li>
  <li data-current>3</li> 
*/
// Разберёмся теперь как их получать.
console.log(document.querySelector('[data-current="3"]'));

// Допустим, что у нас теперь стоит задача получить следующий за ним элемент. То есть <li> с четвёркой внутри. В этом нам поможет команду nextSibling, которую мы используем через точку после получения элемента.
console.log(document.querySelector('[data-current="3"]').nextSibling);

// Аналогично сработает previousSibling, только выведет предыдущего соседа.
console.log(document.querySelector('[data-current="3"]').previousSibling);

// Но вот есть с этими командами одна особенность, это то, что они получают именно узлы. Потому мы легко можем получить, например перенос строки, вместо элемента. Поэтому, чтобы быть уверенными в получении именно элемента, есть специальные команды.
console.log(document.querySelector('[data-current="3"]').nextElementSibling);

// И для предыдущего соответственно тоже.
console.log(
  document.querySelector('[data-current="3"]').previousElementSibling
);

// Также и у parentNode есть аналог для именно получения родительского элемента.
console.log(document.querySelector('[data-current="3"]').parentElement);

// Аналог firstChild будет:
console.log(document.querySelector('.wrapper').firstElementChild);

// Аналог lastChild будет:
console.log(document.querySelector('.wrapper').lastElementChild);

// Также как и на строке 33, мы можем добраться до последнего элемента дочернего элемента от верхнего элемента предыдущего дочернего элемента.
console.log(
  document.querySelector('.wrapper').firstElementChild.lastElementChild
);

console.log('---- ==//== ---- ==//== ---- ==//== ----');
// ? Вот только в случае с childNodes мы пока не наблюдаем аналогов и иногда его создают вручную.
// Т.к. childNodes это у нас псевдо-коллекция, то нам подойдёт forEach() или forOf(), как методы перебора. Иногда мы не можем использовать forEach(), это бывает редко, но такие случаи всё же происходят. В таком случае мы должны использовать перебирающую конструкцию forOf(), чем мы и воспользуемся.
// Например у нас задача перебрать все сущности, что мы получили в childNodes и избавиться от всех текстовых узлов.
// Мы раньше уже узнали, разбирая forOf(), что есть такие операторы break и continue, вот тут они нам и пригодятся.
// Итак node - это переменная для каждой ноды, лежащей внутри document.body.childNodes.
// Для того, чтобы отсортировать, мы сперва зайдём через console.log в свойства childNodes и обнаружим там свойство nodeName со значением "#text". Вот его мы и используем. Т.е. используем условие внутри цикла: если у ноды nodeName является "#text", тогда эта итерация цикла останавливается, ничего не совершает и переходит к следующей.
// console.log(document.body.childNodes);

for (let node of document.body.childNodes) {
  if (node.nodeName == '#text') {
    continue;
  }

  console.log(node);
}
