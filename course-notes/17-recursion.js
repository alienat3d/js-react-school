'use strict';

// * ===/ Рекурсия /===
// * Это когда внутри функции вызывается эта ж функция, т.е. сама себя.

// https://learn.javascript.ru/recursion

// Рассмотрим классический пример из почти любого учебника программирования. Функция возведения в степень.

// Чтобы написать такую функцию существует два подхода.
// 1)
/* function pow(x, n) {
  let result = 1; // Почему 1? Потому, что если было бы 0, то при умножении на любое число мы всегда будем получать ноль, а это не то, что мы бы хотели получить.
  // Далее используем цикл, который закончит действовать, когда итератор i будет меньше степени, которая передаётся.
  for (let i = 0; i < n; i++) {
    result *= x; // *= значит "дополненное умножение", т.е. умножает и присваивает значение одновременно. Тоже самое, что result = x * result;
  }

  return result;
}

console.log(pow(2, 1)); // 2
console.log(pow(2, 2)); // 4
console.log(pow(2, 3)); // 8
console.log(pow(2, 4)); // 16 */

// * 2) Но можно направить мысли и в другое русло. Если у нас функция по возведению в степень, то почему бы нам вместо цикла не запускать её же, пользуясь рекурсией?
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1); // В случае (2, 3) если вместо х приходит двойка, то получается 2 * на результат 2 в n - 1 степени, то есть 2². 2 * 4 = 8.
  }
}
// Получается, что pow(x, n - 1) вычисляет тоже самое, что и выше pow(x, n), но на 1 степень меньше. И когда у нас будет много степеней, то у нас будет вложенность функций. Одна функция будет внутри себя вызывать другую, другую и другую. До тех пор, пока мы не дойдём до какой-то базовой функции, которая нам вернёт двойку, тоже самое, что мы получили в pow(2, 1). Это и есть рекурсия, когда функция внутри себя себя же запускает.

console.log(pow(2, 1)); // 2
console.log(pow(2, 2)); // 4
console.log(pow(2, 3)); // 8
console.log(pow(2, 4)); // 16

// * Рассмотрим ещё пару терминов, которые могут пригодится.
// ? База рекурсии. В данном примере это и была pow(2, 1), т.е. это тот случай, который приводит сразу к завершению функции. Этот случай (строка 26) приводит к тому, что тут же возвращается значение х. И даже если мы запустим какое-то большое значение, то рекурсия в любом случае придёт к своей базе, потому что n каждый раз снижается на 1.

// ? Шаг рекурсии. Это запуск вложенной функции, но уже с другим значением. В данном случае можно заметить, что каждый раз n уменьшается на 1. Это есть шаг рекурсии и можно заметить, что каждый раз 