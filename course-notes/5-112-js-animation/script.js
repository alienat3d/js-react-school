'use strict';

// * === JS-анимации (requestAnimationFrame) === * \\

// ? Мы уже привыкли к тому, что для анимации используем CSS, как самый простой и гибкий способ создания анимаций на странице. Но у них есть некоторые ограничения (на 2022 г.): 1) CSS не умеет нормально анимировать canvas-элементы; 2) Если нужно создать какую-то очень нестандартную рваную анимацию, то в CSS это вряд ли получится. Ведь если посмотреть на CSS3 анимации, то они используют кривые Безье.

// * 1.0.0 JS-анимаций существует как минимум два вида: 1) Реализация через setInterval:

const btn = document.querySelector('.btn'),
  elem = document.querySelector('.box');
let pos = 0;

/* 1.0.1 1) Реализация через setInterval [см. функцию myAnimation() в script.js]. (Понятно, что можно написать и более сложные анимации, которые будут ориентироваться на множество, на множество каких-то переменных и что-то специфическое будут делать с частью интерфейса.) Но у этого способа есть свои проблемы: 
  а) Мы чётко устанавливаем, как именно у нас анимация происходит по кадрам — например здесь мы ставили задержку в 10 миллисекунд. Дело в том, что частота кадров и частота перерисовки браузером страницы может быть непостоянным, в зависимости от разных факторов. А также она стремится к какому-то значению. Но если мы зададим нашу собственную анимацию, то у неё всегда будет жёстко закреплён frame rate. Получается некая рассинхронизация, т.к. наш setTimeout заставляет браузер перерисовывать страницу не в тоже время, когда это он сделал бы сам по себе. А следствием - доп. нагрузка на устройство; 
  б) Ещё одна особенность, если мы начнём запускать много разных анимаций, которые используют setInterval внутри себя и особенно в различные промежутки времени, то это загрузит устройство ещё сильнее;
  в) Если в браузере открыто несколько вкладок и если во время анимации мы переключимся на другую вкладку, то анимации на первой вкладке будут продолжаться также загружая устройство.
  Вывод: Учитывая всё перечисленное можно заключить, что этот способ далёк от идеала, чтобы создавать анимации, тем более какие-то сложные.
*/
// function myAnimation() {
//     let pos = 0;

//     const id = setInterval(frame, 10);
//     function frame() {
//         if (pos == 300) {
//             clearInterval(id);
//         } else {
//             pos++;
//             elem.style.top = pos + "px";
//             elem.style.left = pos + 'px';
//         }
//     }
// }

// * 1.1.0 2) Для решения проблем первого способа (описан выше) была создана функция requestAnimationFrame(). Она позволяет нам запускать какие-то функции в качестве анимаций. Эта функция запускается таким образом, что она берёт анимацию и подстраивает её под частоту обновления страницы браузером. Таким образом нагрузка на ресурсы системы пользователя существенно снизится.
// 1.1.1 Итак создадим ту же самую функцию, только уже при помощи requestAnimationFrame(). Суть requestAnimationFrame в том, что она запускает какую-то функцию в виде коллбэка.
// 1.1.2 Однако здесь сразу замечаем отличие, что переменная pos должна быть глобальной, т.к. она будет контролировать из-вне и каждый раз, когда будет запускаться myAnimation() она будет ссылаться на эту глобальную переменную.
// 1.1.3 Далее мы напишем условие, что если у нас позиция стала меньше 300, то мы запустим анимацию. И туда пропишем собственно сам requestAnimationFrame, который примет в качестве коллбэка myAnimation(). Получается, что когда мы запустим myAnimation(), то условие с requestAnimationFrame зациклит это функцию, пока позиция не достигнет 300.
// 1.1.4 А запускать мы будем также поместив в обработчик события requestAnimationFrame(myAnimation).
function myAnimation() {
  pos++;
  elem.style.top = pos + 'px';
  elem.style.left = pos + 'px';

  if (pos < 300) {
    requestAnimationFrame(myAnimation);
  }
}

btn.addEventListener('click', () => requestAnimationFrame(myAnimation));
// * 1.2.0 Ну и естественно также как и setInterval эту функцию также можно останавливать. Когда мы помещаем requestAnimationFrame() в какую-то переменную, то она также оставляет уникальный ID с нашей анимацией. Ну и чтобы отменить анимацию просто вызываем cancelAnimationFrame() с ID внутри.
let id = requestAnimationFrame(myAnimation);
cancelAnimationFrame(id);


// |===:===:===:===>
/** links:
 * (CSS3 Анимация): https://html5book.ru/css3-animation/
 * (Документация): https://developer.mozilla.org/ru/docs/DOM/window.requestAnimationFrame
 * (Простыми словами): https://html5.by/blog/what-is-requestanimationframe/
 * (Сложные функции анимации): https://learn.javascript.ru/js-animation#funktsii-raschyota-vremeni
 * */