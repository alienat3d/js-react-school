'use strict';

// Довольно давно использовался *функциональный подход* к созданию программ. Что мы делали на прошлых уроках. Это просто набор функций, которые вызываются в нужный момент.

// Теперь появился другой — *Объектно-ориентированный подход. Здесь главную роль играет Объект. Он может содержать в себе методы, свойства, любой вид данных и представляет собой целостную сущность.

// Пример: "легковой автомобиль" — есть огромное разнообразие марок и моделей, но всех можно назвать легковыми автомобилями. Именно это понятие и будет "прототипом", от которого можно уже отпочковывать новые экземпляры. Можно представить любой легковой автомобиль как объект. У него есть такие свойства, как: "двигатель, кузов, колёса и т.д.". У него есть такие методы, как: "езда, перевозка грузов, перевозка пассажиров и т.д." И у всех легковых автомобилей так. Но если посмотреть на потомков нашего легкового автомобиля, то у всех эти качества абсолютно разные: у кого-то более мощный двигатель, у кого-то больше\меньше колёса, какой-то кабриолет, какой-то с кузовом.
// Это и есть применение ООП в реальной жизни. У нас есть объект-прототип с определённым набором характеристик и немного изменяя или добавляя их, мы штампуем новые экземпляры. В программах точно также. Относительно WEB это может быть прототип модального окна, на основании которого мы сделаем несколько новых, не похожих друг на друга. Или прототип пользователя на сайтах и так далее. ООП - это целая наука о том, как делать правильную архитектуру. И в JavaScript такие вещи как массивы и функции — это тоже объекты.

// Главный прототип, описывающий скорость и дистанцию, которую может проехать некая машина.
const car = {
  speed: 250,
  distance: 3000,
  pushingGas: function () {
    console.log('Vrooooom!');
  },
};
// Более конкретная модель машины с корректировкой скорости.
// const gulf = {
//   speed: 150,
// };
// Более правильный способ записи предыдущей переменной с прототипом:
const gulf = Object.create(car); // Создаётся объект и тут же указывается аргументом прототип. Т.е. мы тут создаём объект gulf, который будет прототипно наследоваться от объекта car.

// (Внимание! Устаревший вид записи! Так записывать уже не стоит, однако всё равно может где-то встретится в старом коде.) Чтобы нам показать, что gulf произошёл от car. Теперь gulf унаследует все свойства у car.
// gulf.__proto__ = car;

// ? Более современная запись предыдущей команды "__proto__" будет следующей (первым аргументом будет объект, которому мы будем назначать прототип, а вторым будет собственно сам прототип):
// Object.setPrototypeOf(gulf, car); - Но ещё правильнее было бы создавать прототип ещё на этапе создания переменной gulf.

console.log(gulf);
console.log(gulf.distance); // Сперва пытается найти свойство distance внутри gulf, не находит и переходит в его прототип, то есть в car и находит его.
// Не смотря на то, что у gulp только свойство speed, но так как мы указали его прототипом car, то также и distance будет унаследовано.

// * Такая взаимосвязь сильно помогает в проектах, когда мы можем создать один большой прототип, например модального окна, которое по умолчанию содержит определённые свойства: ширину, высоту, какой-то базовый функционал. И вот основываясь на таком прототипе мы сможем создавать много разных модальных окон, лишь слегка модифицируя их под разные задачи.

// Если мы добавим выше главному прототипу нашей машины функцию pushingGas(), то и gulf сможет её вызвать.
gulf.pushingGas();

// ? Кстати JavaScript можно также назвать и "прототипно ориентированным языком", что будет даже правильнее, чем "объектно-ориентированным". Это частный случай ООП. И мы узнали, что всё в JS строится на прототипах.