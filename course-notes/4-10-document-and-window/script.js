'use strict';

// * === Параметры глобальных объектов document, window и работа с ними === * \\

// 1.1 Получим основной элемент, с которым будем работать
const box = document.querySelector('.box'),
  button = document.querySelector('button');
// 1.2 Допустим, что нам в скрипте для чего-то понадобилось использовать ширину и высоту этого элемента, но без учёта margin & border.
const width = box.clientWidth;
const height = box.clientHeight;

console.log(width);
console.log(height);

console.log(' ');

// ? Зачем нам может быть нужно получать ширину и высоту? Дело в том, что в CSS могут использоваться разные параметры. Могут быть относительные величины, такие как %, VH, VW, которые ориентируются на размер вьюпорта или экрана,пользователя, с которого он просматривает сайт. В таком случае мы не можем взять и получить какое-то количество пикселей из стилей.

// * 2 Иногда может быть необходимо получить контент с полосой прокрутки, также туда войдёт ещё border & margin.
const widthWithMargin = box.offsetWidth;
const heightWithMargin = box.offsetHeight;

console.log(widthWithMargin);
console.log(heightWithMargin);

console.log(' ');

// ? Но это всё про видимую часть контента.

// * 3 Для измерения размеров контента целиком (вместе со скроллом)
const widthWithScroll = box.scrollWidth;
const heightWithScroll = box.scrollHeight;

console.log(widthWithScroll);
console.log(heightWithScroll);

console.log(' ');

// * 4 Применим эти знания практически. Например у нас есть задача, что по клике на кнопку наш элемент со скроллом раскроется на всю высоту контента.

/* button.addEventListener('click', () => {
  box.style.height = box.scrollHeight + 'px';
}); */

// * 5.1 Применений этих свойств довольно много и одни из наиболее частых это scrollTop и scrollLeft. Они помогают узнать сколько проскролленого контента осталось за пределами видимости пользователя. Благодаря этому свойству мы можем придумывать какой-то интерактив внутри прокрутки страницы. Например показывать сверху полоску прогресса, чтобы информировать пользователя какая часть от страницы (или контента) была уже просмотрена.
// 5.2 И если предыдущие свойства мы могли только получить,то эти мы уже можем модифицировать.
button.addEventListener('click', () => {
  console.log(box.scrollTop);
});

// * 6.1 Иногда нужно получать и координаты элемента на странице. В JavaScript координаты высчитываются не так, как в CSS. Они начинают свой отсчёт в левом верхнем углу экрана. (Т.е. например right отсчитывается не от правой кромки экрана, а от левого верхнего угла.) И здесь у нас есть метод, который получает координаты элемента.
const boxPositions = box.getBoundingClientRect().top;

console.log(boxPositions);

// * 7.1 Как же всё таки получить стили, которые были уже применены к элементу на странице при помощи CSS?
// 7.2 Немного отойдём от метрик JS, ведь это тоже важно знать. Почему? Представим такую ситуацию, что нам для какой-то задачи очень важно знать, показан ли элемент на странице или нет. Никаких скриптом мы к нему ещё не применяли и с ним работают лишь CSS стили. Нам нужно определить какое именно значение стоит на свойстве display, там block или none. И на основании этого в условии прописать код. И здесь нам поможет метод глобального объекта window - "getComputedStyle()". Он забирает значение всех уже применённых на элемент стилей, которые отображаются в DevTools в вкладке Computed.
const computedStyle = window.getComputedStyle(box);

console.log(computedStyle.display);

// * 7.3 Две важные особенности, которые относятся к этому методу getComputedStyle: 1) мы можем получить стили псевдо-элементов, однако в JavaScript мы не можем работать с псевдо-элементами, т.к. их по сути нет в DOM. Но стили мы получить сможем:
const stylePseudoElement = window.getComputedStyle(box, '.icon'); // Если бы у box был например псевдоэлемент с классом 'icon'.

// * 7.4 2) Многие новички часто путают Computed Styles с Inline Styles, которые мы используем в JS. Здесь следует помнить, что Computed Styles всегда идут из CSS.

// * 8 Чтобы получить количество пикселей, которое пролистал пользователь на странице, то нужно обращаться не просто к document, а к document.documentElement:
console.log(document.documentElement.clientWidth);
console.log(document.documentElement.scrollTop);

// console.log(document.documentElement.scrollTop = 0); - например используется для кнопки ScrollToTop.

// * 9.1 Есть ещё 2 специфичных метода, которые занимаются положением на странице: "scrollBy" и "scrollTo".
// 9.2 scrollBy - скроллит страницу относительно текущего положения. Например window.scrollBy(0, 400) промотает на 400px вниз от текущего положения на странице.
// 9.3 scrollTo - скроллит страницу относительно всей страницы, а не текущего положения.