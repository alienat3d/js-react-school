import { Component } from 'react';

import Spinner from '../spinner/Spinner';
import ErrorMessage from '../errorMessage/ErrorMessage';
import MarvelService from '../../services/MarvelService';

import './randomChar.scss';
import mjolnir from '../../resources/img/mjolnir.png';

// ? [150.2] (начало в ./src/components/spinner/Spinner.js)

class RandomChar extends Component {
  constructor(props) {
    super(props);
    this.updateCharacter();
  }
  // * 1.0.0 Для спиннера нам понадобится дополнительное свойство в стейте "loading", которое изначально будет в положении true. Он будет отвечать за статус того, идёт сейчас загрузка или нет?

  // * 1.2.1 В стейт запишем новое состояние и оно будет называться "error".
  state = {
    char: {},
    loading: true,
    error: false,
  }
  // 1.1.4 Ну и теперь, чтобы полученные данные убирали спиннер, то при загрузки данных нужно менять стейт loading на false. Добавим в метод, который записывал стейт, при получении данных, чтобы он также менял loading на значение false.
  marvelService = new MarvelService();
  onCharLoaded = (char) => this.setState({
    char,
    loading: false
  })
  // 1.2.2 Также создадим новый метод onError(), который будет устанавливать стейт error в значение true, когда произойдёт ошибка, а loading будет в значении false. Т.к. если произошла ошибка, то следовательно уже нет загрузки и мы скрываем спиннер.
  onError = () => this.setState({ 
    loading: false, 
    error: true 
  })
  // 1.2.3 Далее подумаем о том, когда же у нас может происходить ошибка? Естественно в момент запроса к серверу. И удобно будет использовать .catch() после then(), который выкинет ошибку и пропишем туда новый метод onError.
  // ? 1.2.4 По аналогии к спиннеру, для вывода сообщения ошибки понадобится отдельный компонент, куда мы и поместим картинку, оповещающую пользователя о произошедшей ошибки.
  // todo [перейдём в ./src/components/errorMessage/ErrorMessage.js]
  updateCharacter = () => {
    const id = Math.floor(Math.random() * (1011428 - 1010898) + 1010898);
    // const id = 1011428; // увеличивать ✓
    // const id = 1011100; // уменьшать
    this.marvelService
      .getCharacter(id)
      .then(this.onCharLoaded)
      .catch(this.onError);
  }
  // * 1.0.1 Также нам требуется и сюда добавить стейт loading соответственно. И далее будет условие, что есть loading в положении true, то вернём компонент Spinner. Кстати, такое понятие, когда мы загружаем что-то из условия называется «условный рендеринг», с этим понятием будем довольно часто работать и встречать.
  // * 1.1.0 А теперь применим ещё один приём. Дело в том, что часто в пределах даже одного компонента разработчики разделяют его на несколько частей: логические и рендерящие компоненты (иногда их ещё называют "умные и простые компоненты"). Суть в том, что одни компоненты будут отвечать за логику работы, а другие за отображение интерфейса. Так и сделаем, что сделает код более красивым и оптимизированным. ↓
  // 1.1.2 Теперь мы уже модифицируем код, т.к. здесь нам понадобится уже не деструктуризация char, а только сам объект char.
  // 1.1.3 Далее прописываем прямо в вёрстке выражение условного рендеринга, где мы пропишем тернарным оператором условие, в котором укажем, что если стейт loading в положении true, то мы в этот участок вёрстки вернём компонент со спиннером, а если — false, то кусочек вёрстки с персонажем, компонент View и ему как проп передаём объект char.
  // ? Не стоит прямо в вёрстки делать какие-то сложные вычисления, но выражение условного рендеринга это вполне нормальная практика. ↑
  // * 1.2.0 Иногда какого-то id в базе данных может и не быть, тогда у нас выскочит ошибка. Её нам тоже нужно как-то обработать. Логика будет похожа на показ спиннера, когда мы ловим ошибку — меняем стейт и отображаем другой компонент. ↑
  // * 1.2.9 Итак, когда ErrorMessage готов, то нам нужно модифицировать условие, что если идёт загрузка, то отображаем только спиннер, если произошла ошибка — отобразится ошибка, если успешно получены данные, то рендерим персонажа. И можно было бы написать какое-то больше условие прямо в вёрстке, но скорее всего оно будет плохо понятно и его будет сложно придумать.
  // ? 1.2.10 Обычно, когда стоит задача отображения разных вещей, в зависимости от разных состояний, то эти операции выносят выше, в начало метода render(), как это делают с любыми вычислениями или вытаскиванием стейтов деструктуризацией.
  // 1.2.11 Итак создадим переменную errorMessage, в которую будет помещаться значение из результата тернарного оператора: если у нас ошибка и error в положении true, то показываем компонент ErrorMessage, а если нет, то ничего - null.
  // 1.2.12 Тоже самое делаем и для спиннера.
  // 1.2.13 А дальше создаём переменную content. Контент должен помещаться на страницу тогда, когда у нас уже нет загрузки, но и при этом нет ошибки.
  // 1.2.14 Теперь, когда вся логика отображения компонентов сформирована, то мы можем её подставить в вёрстку. Если у нас в переменную попадает null, то на странице ничего не появится. Поэтому просто перечисляем все 3 переменные подряд.
  render() {
    const { char, loading, error } = this.state;
    const errorMessage = error ? <ErrorMessage /> : null;
    const spinner = loading ? <Spinner /> : null;
    const content = !(loading || error) ? <View char={char} /> : null;

    return (
      <div className="randomchar">
        {errorMessage}
        {spinner}
        {content}
        <div className="randomchar__static">
          <p className="randomchar__title">
            Random character for today!<br />
            Do you want to get to know him better?
          </p>
          <p className="randomchar__title">
            Or choose another one
          </p>
          <button className="button button__main">
            <div className="inner">try it</div>
          </button>
          <img src={mjolnir} alt="mjolnir" className="randomchar__decoration" />
        </div>
      </div>
    )
  }
}
// * 1.1.1 Создадим новый компонент View, который будет просто отображать часть вёрстки с содержимым компонента. Внутрь он примет char, объект с данными о персонаже. А ниже мы вернём кусочек вёрстки, который генерируется динамически (блок с классом "randomchar__block"). Ну и чтобы все данные отобразились, их также следует вытащить из объекта char. Этот View и есть простой\рендерящий компонент — в нём нет никакой логики, он просто принимает аргументом объект с данными, подставляет его свойства в нужные участки кода и возвращает этот код в вёрстку\рендерит его. А вот логические преобразования, запросы на сервер и т.д. идут в основном компоненте RandomChar. ↑
const View = ({ char }) => {
  const { thumbnail, name, description, homepage, wiki } = char;

  return (
    <div className="randomchar__block">
      <img src={thumbnail} alt="Random character" className="randomchar__img" />
      <div className="randomchar__info">
        <p className="randomchar__name">{name}</p>
        <p className="randomchar__descr">{description}</p>
        <div className="randomchar__btns">
          <a href={homepage} className="button button__main">
            <div className="inner">Homepage</div>
          </a>
          <a href={wiki} className="button button__secondary">
            <div className="inner">Wiki</div>
          </a>
        </div>
      </div>
    </div>
  )
}

export default RandomChar;