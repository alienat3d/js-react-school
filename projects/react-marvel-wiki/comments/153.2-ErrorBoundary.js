import { Component } from "react";

import ErrorMessage from "../src/components/errorMessage/ErrorMessage";

// ?[153.2]
// todo начало в [projects\react-marvel-wiki\src\components\charInfo\CharInfo.js]
// * 1.0.3 Это и будет тот компонент, который будет ловить ошибку. У него будет один единственный стейт, содержащий ошибку.
// 1.0.4 Запишем условие, что если стейт error в значении true, то мы будем рендерить запасной интерфейс, если компонент отвалился. Ну, а если ошибок не, то мы рендерим этот компонент. Поэтому раньше мы и называли ErrorBoundary оборачивающим компонентом или предохранителем компоненту, который может сломаться.
// 1.0.5 Здесь используется конструкция this.props.children, которую более подробно будем рассматривать через несколько уроков. Можно пока представить, как другой компонент, который был передан внутрь этого компонента. Как бы его дочерний компонент.
// todo переходим в [projects\react-marvel-wiki\src\components\app\App.js]
class ErrorBoundary extends Component {
  state = {
    error: false
  }
  // * (начало в react-course-notes\7-153-error-boundaries.js) * 2.0.1 У нас есть статичный метод, который принимает объект ошибки и занимается только обновлением стейта. По факту, это всё равно что специальный вид setState, который работает только с ошибками. Никаких сторонних операций внутри не должно быть, поэтому, если нужно сделать что-то дополнительное, то можно смело использовать componentDidCatch.
  // ? 2.0.2 Что из них использовать решаем по обстоятельствам, т.к. работать будет одинаково.
  /*   static getDerivedStateFromError(error) {
      return { error: true };
    } */

  componentDidCatch(error, errorInfo) {
    console.log(error, errorInfo);
    this.setState({
      error: true
    })
  }
  // ? Кстати действительно стоит под каждую ошибку использовать какие-то разные сообщения, оповещая пользователя о том, что какой-то компонент сломался. Но для примера нам хватит и картинки ошибки.
  // ? В консоль мы также получим во-первых информацию об ошибке, в каком файле она произошла и на какой строке, а во-вторых объект с тем компонентом, в котором произошла ошибка. Эту информацию также можно куда-то записать, отправить на какой-то сервер, где эти сообщения записываются для отслеживания ошибок в приложении.
  render() {
    if (this.state.error) {
      return <ErrorMessage />
    }

    return this.props.children;
  }
}

export default ErrorBoundary;