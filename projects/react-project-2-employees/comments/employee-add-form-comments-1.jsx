import { Component } from 'react';
import './employee-add-form.css';
// ? [134]
// * 1.0.0 Поработаем с формой добавления новых сотрудников.
// 1.0.1 Тут у нас в объекте стейта будет два свойства: 1) имя сотрудника и 2) его зарплата.
// 1.0.2 Конечно, нам также надо отслеживать вводимые значения, т.ч. напишем один метод. Причём чтобы он подошёл и к первому инпуту и ко второму. Ведь логика у них будет, на самом деле одна и та же.
// 1.0.3 Пропишем инпутам обработчик события "onChange" и добавим туда метод, который при срабатывании события, то, что будет вводится в этот инпут отправлять в значение нашего стейта.
class EmployeeAddForm extends Component {
  constructor(props) {
    super(props);
    this.state = {
      name: '',
      salary: ''
    }
  }
  // ? Хоть названия для метода можно выбирать любое, но чаще всего, когда у нас происходит какое-то действие, связанное с определёнными действиями пользователя, то чаще всего их называют начиная с on... (это негласное правило).
  // ? Здесь мы можем раскрыть обычный объект, т.к. не привязаны к предыдущему значению стейта.
  // * 1.1.0 Основная проблема здесь это формирование свойства стейт, которое варьируется в зависимости от инпута. И один из вариантов как это можно решить это назначить атрибут "name" на каждый из инпутов и уже от этого отталкиваться. Они будут совпадать с названием свойств в стейте.
  // 1.1.1 И теперь мы можем достучаться до атрибута "name", на котором происходит событие и он будет заменён на соответствующую его значению строку и записан в стейт. Но, чтобы провернуть такой финт нам нужно облачить "evt.target.name" в квадратные скобки. Т.о. мы можем записать свойство в объект. Это подходит как раз для таких случаев, когда у нас свойство составное.
  // * 1.2.0 == Управляемые компоненты ==
  // 1.2.1 Установим нашим инпутам такой атрибут, как "value". Если мы хотим, чтобы реакт-компонент рендерил форму и контролировал её поведение в ответ на пользовательский ввод, то мы должны добавить этот атрибут и в него помещать значение стейта.
  // 1.2.2 Итак, теперь, когда у нас пользователь вводит что-то в инпут, то запускается событие onChange, запускает метод onValueChange(), там запускается метод setState, которое изменяет состояние и записывает его в стейт под нужным свойством. А так как атрибут value у нас связан со значением стейта для этого инпута. Т.о. значение value строки ввода будет контролироваться реактом. А сам такой элемент будет называться "управляемым элементом". У нас идёт как бы двойное связывание.
  // ? 1.2.3 Преимущество таких контролируемых компонентов\элементов в том, что у нас всегда есть слой каких-то данных. И стейт синхронизирован с интерфейсом. И теперь на все изменения в стейте интерфейс будет реагировать мгновенно. И особенно это будет полезно при валидации данных — мы можем провалидировать значение, которое было введено и тут же отправили в value, а также возможно сделали попутно какие-то операции. В большинстве случаев нам потребуются именно такие контролируемые компоненты, у которых идёт связь этих данных.
  // ? Единственным инпутом, который будет в реакте неуправляемым это <input type="file" />
  onValueChange = (evt) => {
    if (evt.target.type === 'text') {
      evt.target.value = evt.target.value.replace(/\d/g, '')
      this.setState({
        [evt.target.name]: evt.target.value
      })
    } else {
      this.setState({
        [evt.target.name]: evt.target.value
      })
    }
  }
  render() {
    const {name, salary} = this.state;
    return (
      <div className="app-add-form">
        <h3>Добавьте нового сотрудника</h3>
        <form className="add-form d-flex">
          <input 
            className="form-control new-post-label" type="text"
            placeholder="Как его зовут?"
            name="name"
            value={name}
            onChange={this.onValueChange} />
          <input 
            className="form-control new-post-label" type="number"
            placeholder="Зарплата в ₽?"
            name="salary"
            value={salary}
            onChange={this.onValueChange} />
          <button 
            className="btn btn-outline-light"
            type="submit">
              Добавить
          </button>
        </form>
      </div>
    );
  }
}

export default EmployeeAddForm;