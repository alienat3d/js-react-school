import { Component } from 'react';

import AppInfo from '../src/components/app-info/app-info';
import SearchPanel from '../src/components/search-panel/search-panel';
import AppFilter from '../src/components/app-filter/app-filter';
import EmployeesList from '../src/components/employees-list/employees-list';
import EmployeeAddForm from '../src/components/employee-add-form/employee-add-form';

import './app.css';

// ? [135]
// todo [начало в employees-list\employees-list.jsx]

// * 1.0.6 Раз это сработало между этими компонентами, то почему бы нам не перейти в главный компонент app и не передать EmployeesList, там где мы уже передавали массив данных "data", проп onDelete.

// todo [перейдём в employees-list-item\employees-list.jsx]
// * 1.1 Теперь переделаем App в класс, чтобы воспользоваться классовым стейтом, ведь динамически изменять мы можем что-то только внутри стейта.
// * 1.2.0 Добавим метод deleteItem, т.к. этот функционал у нас будет повторяться и поэтому лучше вынести его в отдельный метод.

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      data: [
        { name: 'Денис Андреевич Зайцев', salary: 42000, isIncreased: false, id: 0 },
        { name: 'Дмитрий Дмитриевич Дёмин', salary: 177000, isIncreased: false, id: 1 },
        { name: 'Алексей Васильевич Цвайг', salary: 400000, isIncreased: true, id: 2 },
        { name: 'Семён Моисеевич Циммерман', salary: 195000, isIncreased: false, id: 3 },
        { name: 'Алёна Алексеевна Воробьёва', salary: 105000, isIncreased: true, id: 4 }
      ]
    }
  }
  // 1.2.2 Вспоминаем, чтобы удалить сотрудника из стейта нужно вызывать this.setState({...}).
  // 1.2.3 Какой вообще алгоритм удаления какого-то элемента из массива с объектами, где мы ориентируемся по id? 1) Сначала мы передали метод deleteItem() в самый них иерархии приёмом "property drill". Теперь он вызывается с определённым уникальным id. 2) Мы берём этот id и по нему ищем нужный item внутри массива, чтобы его потом удалить. 3) Обновляем стейт уже без этого объекта, чтобы реакт мог перерендерить соответствующий этому стейту компонент.
  // * 1.2.4 Итак, пункт №1 мы уже выполнили, теперь №2 — ищем нужный item. Используем довольно универсальный приём, который довольно часто встречается в практике: Чтобы найти определённый объект нам нужен его индекс. Создадим переменную и потом применим к нашему массиву объектов метод findIndex().
  // ? 1.2.5 findIndex() принимает в себя коллбэк-функцию, которая запускается и если она вернёт true, то из этого метода будет возвращён номер элемента, на котором сработала эта функция. 'element' - это каждый элемент массива, который мы проверяем. И мы укажем, что сравнивать будем element.id с тем id, который приходит в метод deleteItem изначально при клике на кнопку "корзинка".(Здесь намеренно нестрогое сравнение, т.к. могут быть разные данные. Но когда мы возвращаем что-то с нашей страницы, то там может прийти строка.) Теперь у нас в переменной index будет индекс того объекта, который нам нужно удалить.
  // * 1.2.6 Осталось лишь удалить его из стейта. Сперва стоит вспомнить про иммутабельность стейта (его неизменяемость). Напрямую через this.state его поменять нельзя. Мы не должны его мутировать, иначе это нарушает логику реакта, не будем учитывать асинхронность и всё с этим связанное.
  // ? Иммутабельность — это когда объект не может быть изменён после своего создания. Вот появился он в коде и всё, никакие модификации в нём мы проводить уже не можем. Но, чтобы внести какие-то изменения, мы можем создать копию этого объекта с внесёнными нововведениями. (Когда-то раньше в начале изучения базы нативного JS мы проходили клонирование объектов, как раз для таких случаев.) 
  /* Такой подход даёт много плюсов: 
    -> сравнивая внутренности старого и нового объекта становятся довольно хорошо видимыми отличия;
    -> в свою очередь это отлично подходит для алгоритмов сравнения;
    -> тестировать такие изменения будет также довольно легко.
      Из минусов:
    - при таком подходе будет расходоваться чуть больше памяти (каждый раз будут создаваться всё новые и новые копии объектов), но это не такая уж большая цена, учитывая объёмы памяти современных устройств.
  */
  // * 1.2.7 Итак, вернёмся к коду, что можно сделать? Можно пойти для примера сперва неправильным путём и мутировать стейт. Применим к массиву "data" метод массивов splice(), который удаляет определённый элемент из массива. Первым аргументом индекс элемента с которого надо удалять и вторым количество элементов.
  // * 1.2.8 А дальше рассмотрим правильный вариант, соблюдая принцип иммутабельности. Нам нужно создать новый массив, копию старого, но без того элемента, который мы удалили. Здесь несколько вариантов реализации:
  // * 1.2.9 1-ый вариант, более длинный, при помощи метода slice(), который скопирует часть массива и создаст новый. Применяем метод slice() на data и первым аргументом он примет индекс с какого элемента нам нужно копировать, укажем - 0, т.е. самый первый. И дальше мы копируем лишь часть массива до того элемента, который мы хотим удалить, т.е. пишем index. Далее во вторую переменную after мы запишем почти тоже самое, только первым аргументом запишем index + 1, что значит со следующего элемента, после того, который мы хотим удалить. Второй аргумент не указываем, что означает "до конца массива". Т.о. мы создали копии двух частей массива, куда не входит тот элемент, от которого мы хотим избавиться.
  // * 1.2.10 А затем в новую переменную разворачиваем спред-операторами оба кусочка друг за другом. И этот новый массив мы вернём в качестве значения в data.

  // * 1.3.0 Однако есть и второй способ, который явно покороче предыдущего. Мы можем взять массив data и отфильтровать его методом filter() с формированием нового массива. И тут мы просто отфильтруем наш массив, сформировав новый, где находятся все элементы кроме того, который совпал по id.
  deleteItem = (id) => {
    this.setState(({data}) => {
      // const index = data.findIndex(element => element.id === id);
      // data.splice(index, 1); // - неправильный вариант мутирует стейт
      // Первый рабочий, но длинный вариант:
/*       const before = data.slice(0, index);
      const after = data.slice(index + 1, );
      const newArray = [...before, ...after]; */
      return {
        // data: newArray
        data: data.filter(item => item.id !== id)
      }
    })
  }
  // 1.2.1 Теперь в onDelete мы уже будем передавать наш метод deleteItem
  render() {
    return (
      <div className="app">
        <AppInfo />
        <div className="search-panel">
          <SearchPanel />
          <AppFilter />
        </div>
        <EmployeesList
          data={this.state.data}
          // onDelete={id => console.log(id)} />
          onDelete={this.deleteItem} />
        <EmployeeAddForm />
      </div>
    );
  }
}

export default App;