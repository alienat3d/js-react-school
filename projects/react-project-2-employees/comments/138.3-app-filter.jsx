import './app-filter.css';

// ? [138.3]
// todo [начало в app/app.jsx]
// * 2.2.0 Итак, у нас тут три разные кнопки, которые должны отслеживать определённые события.
// ? Для доп. информации можем рассмотреть ещё один подход, который будет встречаться в практике и использоваться. Дело в том, что когда кнопок много, особенно фильтров, то они часто приходят к нам не в качестве какой-то вёрстки, а расположены в каком-то массиве с данными (так даже удобнее работать). Такой подход будет, как специалиста более выгодно презентовать.
// ? 2.2.1 Здесь не потребуется стейт, т.к. кнопка никакого value не содержит, а действия мы передадим через пропсы. Т.ч. оставим здесь функциональные компоненты.
// 2.2.2 Итак, сформируем кнопки в buttonsData.
// 2.2.3 Теперь на базе этих данных можно сформировать элементы, как мы это делали с сотрудниками. В map() у нас будет каждый отдельный элемент, из которого мы вытащим нужные нам данные. И вернём уже структуру кнопки, куда будем подставлять name и label, где label - будет тем текстовым контентом, что внутри кнопки, а name пойдёт у нас в атрибут key, который используется для алгоритма сравнения.
// 2.2.4 Теперь разберёмся с классами. Если бы у каждой кнопки у нас классы сильно различались, то нормальным подходом было бы указать их прямо свойством в каждом объекте. Но здесь такая ситуация, что у всех кнопок, кроме активной одинаковые классы "btn-outline-light", а у активной этот класс заменяется на "btn-light".
// todo [перейдём в app\app.jsx]
// * 2.2.6 Теперь у нас в props.filter лежит название фильтра, которое совпадает с одним из значений свойств name в объектах массива buttonsData. Тогда мы можем создать переменную active, в которой мы будем определять активный этот элемент или нет.
// todo [перейдём в app\app.jsx]
// * 2.3.2 Осталось обратиться к пропсам и назначить обработчик события "onClick", в которой вызовем коллбэк-функцию "onFilterSelect", также незабудем про аргумент name (название нашего фильтра).
const AppFilter = (props) => {
  const buttonsData = [
    {name: 'all', label: 'Все сотрудники'},
    {name: 'rise', label: 'На повышение'},
    {name: '> 100000', label: 'Зарплата > ₽100000'}
  ];
  const buttons = buttonsData.map(({name, label}) => {
    const active = props.filter === name; // ? 2.2.7 if props.filter равняется значению в свойстве name, то передаём true в active. Полезный приём, стоит запомнить.
    const clazz = active ? 'btn-light' : 'btn-outline-light'; // ? 2.2.8 Ещё один приём, который пришёл из Java, используем спец. переменную "clazz". Берём active и проверим его при помощи тернарника, т.к. active в значении true будет лишь раз, то и только одна кнопка у нас будет с классом активности. И немного отредактируем className у нашей заготовки кнопки.
    return (
      <button
        className={`btn ${clazz}`}
        type="button"
        key={name}
        onClick={() => props.onFilterSelect(name)} >
        {label}
      </button>
    )
  })

  return (
    <div className="btn-group">
      {buttons}
    </div>
  );
}

export default AppFilter;