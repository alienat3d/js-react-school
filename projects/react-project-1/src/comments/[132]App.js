import { Component } from 'react';

import './App.css';

// * == События в реакт == * \\
// todo [начало в react-course-notes\6-132-events.js]
// 1.1.3 [начало в самом конце кода] Каждый вариант будет встречаться в практике и с каждым хорошо бы быть знакомым.
// * 1.1.4 С помощью bind(). Сперва перейдём в конструктор где мы допишем следующую конструкцию: this.nextYear = this.nextYear.bind(this). Разберём, что же это всё значит: слева у нас "this.nextYear" обычное свойство, которое будет у экземпляра класса. Справа мы обращаемся к "this.nextYear" (к методу, который есть в классе) и мы его "привязываем" методом bind() к конкретному экземпляру класса, помещая внутрь "this". Неудобство заключается в том, что нам придётся подобным образом байндить все методы в классе, которое используются в обработчиках событий.
// * 1.1.5 Есть второй более удобный способ, использовать новый синтаксис полей классов и стрелочные функции. Этот способ гораздо более распространён и любим разработчиками за своё удобство.
// * 1.1.6 Ну и третий способ привязать контекст, чтобы он не терялся. И заключается он в вызове события через анонимную стрелочную функцию:
// * <button onClick={() => this.nextYear}></button>
// * И здесь, когда будет произведён клик по этой кнопке, то запустится прописанная внутри анонимная стрелочная функция, внутри запустится this.nextYear(), и за счёт того, что this стрелочная функция берёт у своего родителя, в него попадёт ссылка на экземпляр нового класса.
// ? Однако с этим способом может быть одна проблема, что каждый раз, когда будет создаваться компонент WhoAmI, то будет также создаваться новая коллбэк-функция. Это же касается и setState(), потому, что она запускает метод render() и каждый раз когда запускается render() будет создаваться эта коллбэк-функция. И проблемы могут возникнуть, если эта коллбэк-функция передаётся куда-то дальше по иерархии в виде пропсов. Вспоминая тему реконциляции, что если у такого компонента меняется проп, то это заставит его заново перерендериться на странице и мы немного потеряем в оптимизации.
// ? В действительности, при вызове setState() благодаря алгоритму реконциляции перерендерены будут лишь те теги, которые используют стейты, не смотря на то, что метод render() будет вызываться каждый раз.
class WhoAmI extends Component {
  constructor(props) {
    super(props);
    this.state = {
      age: 37,
      text: '+',
      occupation: ''
    }
    // this.nextYear = this.nextYear.bind(this); // [1.1.4]
  }
  // [1.1.4], [1.1.6]:
  /*     nextYear() {
        this.setState(state => ({
          age: state.age + 1
        }));
      } */
  // [1.1.5]:
  nextYear = () => {
    this.setState(state => ({
      age: state.age + 1
    }));
  }
  // * 1.1.0 Создадим также специальную функцию, которая будет менять стейт, а точнее заносить в его свойство occupation ту строку, что введёт пользователь. И здесь нас не слишком волнует предыдущий стейт, а нам нужен лишь конечный результат введённого в строку ввода, а значит можно обойтись без коллбэк-функции.
  commitInputChanges = (evt, color) => {
    console.log(color);
    this.setState({
      occupation: evt.target.value
    })
  }

  // * 1.0.0 Итак, добавим в нашу заготовку форму с лейблом и строкой ввода и кнопкой отправки.
  // 1.0.1 Сделаем так, чтобы при введении каких-то символов в этот инпут они попадали в стейт и после этого выводились в вёрстку.
  // ? Кстати, в реакте события onChange & onInput работают одинаково, в отличии от нативного JS. Но чаще всего используется onChange.

  // * 1.2.0 == Использование аргументов в обработчиках событий ==
  // 1.2.1 При такой записи, как например "onChange={this.commitInputChanges}" мы не можем в этот метод передать какие-то аргументы (цвет, размер шрифта и т.д.). У нас только автоматически придёт аргументом объект события, который мы потом используем. Это поведение можно модифицировать, чтобы иметь возможность что-то ещё туда передавать. Для этого мы просто используем стрелочную функцию. Не забудем передать объект события. И кроме этого нам понадобится какой-то доп. аргумент, ради чего всё это и затевалось.
  // 1.2.2 Теперь внутрь commitInputChanges() мы перекинем объект события и добавляем какой-то аргумент. Теперь мы можем добавить этот аргумент и в наш метод выше. "color" ↑
  render() {
    const { name, surname, link } = this.props;
    const { age, occupation } = this.state;
    return (
      <div className='wrapper'>
        {/* <button onClick={() => this.nextYear()}> [1.1.6] ↑ */}
        <button onClick={this.nextYear}>
          {this.state.text}
        </button>
        <h2>My name is {name} {surname}. I’m {age} years old.</h2>
        <h3>My occupation is {occupation}.</h3>
        <a href={link}>My LinkedIn Profile</a>
        <form>
          <label htmlFor="occupation">
            Type your occupation
            {/* <input
              type='text'
              id='occupation'
              onChange={this.commitInputChanges} /> */}
            <input
              type='text'
              id='occupation'
              onChange={(evt) => this.commitInputChanges(evt, 'some color')} />
          </label>
        </form>
      </div>
    )
  };
}

function App() {
  return (
    <div className="App">
      <WhoAmI name='Al' surname='Tsaplin' link='https://www.linkedin.com/in/altdev/' />
      <WhoAmI name='Andrey' surname='Teplonogov' link='https://www.linkedin.com/in/antepliy/' />
    </div>
  );
}

// todo 1.1.0 Важное замечание про "this", которое мы указываем и в стейтах и в пропсах, оно указывает на экземпляр класса. Это отдельная сущность, которая как бы отпочковывается от нашего общего класса-шаблона и с помощью ключевого слова "this" мы указываем на отдельный экземпляр класса, чтобы у каждого компонента были свои стейты и пропсы.
// * 1.1.1 И вот, когда мы работаем здесь со стейтами и пропсами, то здесь всё довольно просто, т.к. this всегда будет ссылаться на этот экземпляр, но с обработчиками событий всё немного сложнее. Когда событие срабатывает — контекст теряется. Это происходит потому, что у нас функция вызывается внутри другой функции и тогда this становится undefined.
// 1.1.2 Чтобы убедиться можно переписать нашу функцию nextYear() из стрелочной функции переделать в формат обычного метода. И тогда у нас всё сломается с ошибкой "Cannot read properties of undefined (reading 'setState')". Это происходит потому, что функция setState() вызывается в nextYear(), а nextYear() вызовется в render(). В итоге контекст у нас потеряется. Поэтому давайте рассмотрим 3 варианта как избежать этой проблемы. ↑
/* nextYear () {
  this.setState(state => ({
    age: state.age + 1
  }));
} */

export default App;
