import { Component } from 'react';

import './App.css';

// todo Начало в [react-course-notes\6-130-component-state-memory.js]

// * 1.0.0 Для начала переделаем нашу заготовку в формат класса, чтобы посмотреть как работают стейты в классовых компонентах. Для этого нам необходимо импортировать React.Component. ↑
// * 1.0.2 Чтобы в экземпляры классов передать пропсы нам нужно использовать конструктор. И вот в этот конструктор нам и приходит аргумент пропс.
// 1.0.3 Далее, чтобы использовать пропсы мы пропишем ключевое слово super и в него передадим пропсы. (Возможность работать с пропсами как раз наследуется от React.Component и теперь у каждого потомка класса (экземпляра) будет свойство this.props с объектом, который будет содержать все переданные нам пропсы.)
// 1.0.4 Теперь, с помощью деструктуризации вытащим из this.props наши пропсы "name", "surname" и "link".
// ? Если кроме пропсов в конструкторе больше нет никаких других действий, то можно обойтись и без него.
// * 1.1.0 Но как же всё таки менять данные внутри компонентов, если пропсы у нас только для чтения (если не нарушать правил реакта)? Здесь приходят на помощь стейты, которые можно динамически менять внутри компонентов.
// * 1.1.1 Чтобы создать стейт мы в конструкторе пропишем this.state и поместим в него объект. Этот объект и будет являться стейтом, описывающим динамически изменяемую часть нашего компонента.
// * 1.2.0 Теперь сделаем, чтобы этот стейт как-то менялся, был динамическим. Для этого добавим кнопку. Ей пропишем атрибут "onClick" и внутрь передаём название метода. Не вызываем, а передаём название. Это аналог addEventListener из нативного JS.
// 1.3.1 Допустим у нас также есть свойство text и его значение нужно передавать в контент кнопки. ↓
class WhoAmI extends Component {
  constructor(props) {
    super(props);
    this.state = {
      age: 37,
      text: '+'
    }
  }
  // todo Здесь важно использовать именно стрелочную функцию.
  // * 1.2.1 Чтобы правильно поменять стейт нужно использовать this.setState(). Внутрь она принимает объект с новым стейтом.
  // 1.2.2 Также стоит знать, что когда команда setState() запускается, то она перерендерит весь компонент с новым состоянием. Т.е. вызов метода render(). Более подробно эта тема будет рассматриваться в теме жизненный цикл всего компонента.
  // * 1.2.3 Ещё один важный нюанс по работе команды setState(). Сейчас, как и в 95% других случаях, наш стейт будет зависеть от предыдущего стейта. Когда мы будем увеличивать на единичку, то мы знаем, что к предыдущему значению стейта прибавится 1. Но команда setState() выполняется асинхронно. И может так случиться, что предыдущий стейт не обновился, а мы его уже пытаемся снова обновить. (Представим, что пользователь кликал настолько быстро, что у него сбился счётчик. А это не то, что нам хотелось бы.) Такое поведение реакта вызвано оптимизацией работы. Но если мы хотим это обойти, то мы могли бы внутрь setState() передать другую коллбэк-функцию. Это будет сигнал реакту, чтобы он выполнил эту функцию только тогда, когда предыдущий стейт поменяется. Но в этом случае мы удалим "this" (ведь стейт уже и так приходит и мы просто обращаемся к его свойству age). Итак, ещё раз, мы говорим, что в setState() передаётся коллбэк-функция, а в неё передаётся 1 аргумент стейт (наше текущее на данный момент состояние), затем эта коллбэк-функция вернёт другой объект.
  // ? 1.2.4 Однако бывают случаи, когда значение стейт не зависит от предыдущего, например такое бывает при вводе текста в инпут (там не важно какой символ мы ввели до этого, а нам важен конечный результат). В таком случае мы просто передадим объект. А если стейт напрямую зависит от предыдущего значения стейта. То в таком случае лучше себя обезопасить и передавать коллбэк-функцию с аргументом в виде стейта. (Иногда и здесь применяют деструктуризацию)
  // * 1.3.0 Стейт может содержать множество свойств. ↑
  // 1.3.2 Резонный вопрос, а что же будет происходить со вторым значением стейта "text", когда мы будем менять стейт "age"? Команда setState() устроена так, что она поменяет только то, что мы укажем и оставит как было все остальные свойства объекта стейт.
  nextYear = () => {
    console.log('A year added');
    /* this.setState({
      age: this.state.age + 1
    }); */
    this.setState(state => ({
      age: state.age + 1
    }));
  }

  render() {
    const { name, surname, link } = this.props;
    return (
      <div className='wrapper'>
        <button onClick={this.nextYear}>
          {this.state.text}
          {/* <img className='btn-icon' src='./img/plus.svg' alt="" /> */}
        </button>
        <h2>My name is {name} {surname}. I’m {this.state.age} years old.</h2>
        <a href={link}>My LinkedIn Profile</a>
      </div>
    )
  };
}

// * 1.0.1 Заодно разберёмся как работают пропсы в классовых компонентах. Когда классовый компонент вызывается, то он создаёт свой экземпляр. И вот мы видим два экземпляра нашего класса с разными пропсами. 
function App() {
  return (
    <div className="App">
      <WhoAmI name='Al' surname='Tsaplin' link='https://www.linkedin.com/in/altdev/' />
      <WhoAmI name='Andrey' surname='Teplonogov' link='https://www.linkedin.com/in/antepliy/' />
    </div>
  );
}

export default App;
