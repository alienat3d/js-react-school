// import React from 'react';
import { Component } from 'react';
import './App.css';
// todo Начало в [react-course-notes/5-123-react-components.js]
// * 1.4.0 Здесь мы видим функцию App, которая экспортируется в index.js новых React-проектах по умолчанию и вставляется в качестве демонстрации на страницу. 
// ? 1.4.1 Компоненты это функции, которые могут возвращать JSX-элементы и внутри себя могут содержать какое-то поведение.
// 1.4.2 Итак, рассмотрим структуру функции React-компонента в деталях: 
/* 
1) У нас есть ключевое слово return для возврата JSX-элементов из функции;
2) Один родительский тег с классом "App";
3) тег шапки, в котором лого-картинка и параграф.
*/
// 1.4.3 Кстати, логотип мы тоже импортируем из-вне, указывая к нему путь выше. ↑
/* function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Hello, Al! How are you doing today? :)
        </p>
      </header>
    </div>
  );
} */
// * 1.5.0 Теперь для тренировки пропишем свои компоненты, которые будут помещаться на страницу.
// 1.5.1 Сперва создадим переменную, но назовём её уже с большой буквы, обозначая как React-компонент. Далее поместим в неё функцию. Пока она будет возвращать заголовок.
const Header = () => {
  return <h2>Hello World!</h2>
}
// * 1.6 Создадим ещё один компонент Field
// * 1.9.0 Vs можем манипулировать внутренностями атрибутов, как и самими внутренностями элементов.
// 1.9.1 Некоторые атрибуты нам нужно будет динамически формировать, особенно что касается CSS-классов.
// 1.9.2 Добавим ещё одну переменную, которая будет содержать в себе самые простейшие стили, которые мы применим к реакт-элементу инпуту. В реакте они назначаются при помощи объекта.
const Field = () => {
  const pholder = 'Enter here';
  const styledField = {
    width: '300px',
    padding: '10px 12px'
  };
  // ? Когда атрибутов становится много, их обычно выстраивают в столбик для лучшей читабельности кода:
  return <input 
          placeholder={pholder} 
          type='text' 
          style={styledField}/>
}
// * 1.10.0 Рассмотрим вариант, если мы хотим сделать компонент с помощью классового подхода (хотя в последнее время всё больше в тренде именно функциональный подход). Тут есть следующее правило: Чтобы классы в реакте работали правильно, мы должны унаследовать какое-то поведение от базового класса, который есть в реакте, т.е. reactComponent. Для того, чтобы наши классы умели делать всё то, что задумывалось в реакт, нам необходимо взять компонент, который создан в самом реакте и сделать его наследником новый компонент.
// 1.10.1 Сперва импортируем сюда React. ↑
// 1.10.2 Ну, а дальше после ключевого слова extends прописываем главный компонент объекта React - Component. Т.о. мы взяли этот главный компонент реакта и позволили Field унаследовать все его свойства. 
// class Field extends React.Component {
// 1.10.3 Кстати, для более краткой записи обычно применяют при импорте деструктуризацию и импортируют сразу Component, тогда запишем уже class Field extends Component {}.
// 1.10.4 Внутри у нас будет главный метод render() для отрисовки элементов компонента на странице.
/* class Field extends Component {
  render() {
    const pholder = 'Enter here';
    const styledField = {
    width: '300px',
    padding: '10px 12px'
    }

    return <input 
            placeholder={pholder} 
            type='text' 
            style={styledField}/>
  };
} */

// ? 1.11 И всё таки синтаксис имеет значение и в разных ситуациях может быть уместно использовать тот или иной подход.

// * 1.7.0 И ещё один компонент, который мы создадим в виде функции.
// 1.7.1 Внутри функции мы можем объявлять ещё переменные.
// 1.7.2 Также внутрь элементов можно помещать и вызов JS-функции. Например здесь функция в переменной result вернёт нам строку "Log in", которая будет помещена в качестве контента кнопки.
// 1.7.3 Кроме того, внутри элементов можно помещать и другие элементы.
/* function Button() {
  // const text = 'Log in'
  const result = () => {
    return 'Log in'
  }
  const something = <span>Что-то</span>,
    somewhat = <span>чем-то</span>

  return <button>{something} c {somewhat}</button>
} */
// * 1.8.0 Представим, что у нас кнопка с какой-то логикой, которая проверяет залогинился ли пользователь на наш сайт или нет. Таким образом тернарным оператором мы проверим, что если переменная isLogged в значении true, то кнопка будет иметь значение "Enter", а если false - примет значение переменной text.
// 1.8.1 Таким образом мы можем подставлять условия с тернарным оператором прямо внутрь {}, однако обычные if else, условия подставить не получится. Если мы хотим использовать именно их, то следует их прописать выше, поместить результат в переменную и подставлять уже её. С этим проблем не будет.
function Button() {
  const text = 'Log in',
    isLogged = false

  return <button>{isLogged ? 'Enter' : text}</button>
}
// 1.5.2 Теперь, когда у нас есть уже один React-компонент, нам нужно его куда-то поместить. Например внутри другого компонента.
// 1.5.3 Далее у нас есть два варианта, либо поместить этот компонента как обычный тег: <Header></Header>, либо, если у компонента нет внутренностей, то можно закрыть его сразу <Header/>.
function App() {
  return (
    <div className="App">
      {/* <Header></Header> */}
      <Header/>
      <Field/>
      <Button/>
    </div>
  );
}

// ? Но если здесь у нас компоненты состоят всего из одного элемента, то как понять по какому принципу формировать компоненты? Ответ: Если мы можем представить, что этот компонент можно будет переиспользовать где-то в другой части приложения или какой-то компонент стал слишком большим, то смело применяем этот приём. Ну либо, если внутри компонента начинает проявляться какая-то логика, то мы должны также выразить её внутри отдельного компонента.

export {Header};
export {Field};
export {Button};
export default App;
